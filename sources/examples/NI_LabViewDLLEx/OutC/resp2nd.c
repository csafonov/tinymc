//File: resp2nd.c 
//Generated by TMC Converter(C)2009-2013
#include "tmc.h"
#include "stdtmc.h"

#include "TestO.globals.h"

// User provided C-code header (must be included in include path):
#include "External_func.h"

// % Lines 1--3:
//function [Mag,Ph,num,den]=resp2nd(w1,d1,w2,d2,w)

//% calculate response of second-order filter

//s = j*w;

void tmcresp2nd(int nargout, int nargin,tmsMatrix *Mag,tmsMatrix *Ph,tmsMatrix *num,tmsMatrix *den
,tmsMatrix *w1,tmsMatrix *d1,tmsMatrix *w2,tmsMatrix *d2,tmsMatrix *w) {
tmsMatrix **reg=tmcCreateRegFrame(89);
tmsMatrix *s=tmcNewMatrix();
tmsMatrix *P=tmcNewMatrix();

TRY
TMC_DBG_PUSH_STACK_VAR("resp2nd",11,
w1,"w1",
d1,"d1",
w2,"w2",
d2,"d2",
w,"w",
Mag,"Mag",
Ph,"Ph",
num,"num",
den,"den",
s,"s",
P,"P");

//CALL function
tmcReallocRegister(reg[1]);
tmcj(1,0, reg[1]);

tmcMul(reg[3],reg[1],w);

tmcAssign(s,reg[3]);
//statement here,line 3

// % Lines 4--4:
//P = (s.^2 +  2 * d1 * w1 * s + w1 ^ 2) ./ (s.^2 +  2 * d2 * w2 * s + w2 ^ 2  ) * (w2/w1)^2 ;


tmcScalar(reg[6],2.000000000000000e+000);
tmcPowerScalar(reg[7],s,reg[6]);
tmcScalar(reg[8],2.000000000000000e+000);

tmcMul(reg[10],reg[8],d1);

tmcMul(reg[12],reg[10],w1);

tmcMul(reg[14],reg[12],s);
tmcAdd(reg[15],reg[7],reg[14]);

tmcScalar(reg[17],2.000000000000000e+000);
tmcPower(reg[18],w1,reg[17]);
tmcAdd(reg[19],reg[15],reg[18]);

tmcScalar(reg[21],2.000000000000000e+000);
tmcPowerScalar(reg[22],s,reg[21]);
tmcScalar(reg[23],2.000000000000000e+000);

tmcMul(reg[25],reg[23],d2);

tmcMul(reg[27],reg[25],w2);

tmcMul(reg[29],reg[27],s);
tmcAdd(reg[30],reg[22],reg[29]);

tmcScalar(reg[32],2.000000000000000e+000);
tmcPower(reg[33],w2,reg[32]);
tmcAdd(reg[34],reg[30],reg[33]);
tmcDivScalar(reg[35],reg[19],reg[34]);


tmcDiv(reg[38],w2,w1);
tmcScalar(reg[39],2.000000000000000e+000);
tmcPower(reg[40],reg[38],reg[39]);
tmcMul(reg[41],reg[35],reg[40]);

tmcAssign(P,reg[41]);
//statement here,line 4

// % Lines 5--5:
//Mag = 20* log10(abs(P));

tmcScalar(reg[43],2.000000000000000e+001);

//CALL function
tmcReallocRegister(reg[45]);
tmcabs(1,1, reg[45], P);
//CALL function
tmcReallocRegister(reg[46]);
tmclog10(1,1, reg[46], reg[45]);
tmcMul(reg[47],reg[43],reg[46]);

tmcAssign(Mag,reg[47]);
//statement here,line 5

// % Lines 6--6:
//Ph = unwrap( angle( P ) ) /pi * 180;


//CALL function
tmcReallocRegister(reg[50]);
tmcangle(1,1, reg[50], P);
//CALL function
tmcReallocRegister(reg[51]);
tmcunwrap(1,1, reg[51], reg[50],NULL);
//CALL function
tmcReallocRegister(reg[52]);
tmcpi(1,0, reg[52]);
tmcDiv(reg[53],reg[51],reg[52]);
tmcScalar(reg[54],1.800000000000000e+002);
tmcMul(reg[55],reg[53],reg[54]);

tmcAssign(Ph,reg[55]);
//statement here,line 6

// % Lines 7--8:
//

//num = [1, 2 * d1 * w1,  w1^2] / w1^2;

tmcScalar(reg[57],1.000000000000000e+000);
tmcScalar(reg[58],2.000000000000000e+000);

tmcMul(reg[60],reg[58],d1);

tmcMul(reg[62],reg[60],w1);

tmcScalar(reg[64],2.000000000000000e+000);
tmcPower(reg[65],w1,reg[64]);
tmcCollectColumns(reg[66],3,reg[57],reg[62],reg[65]);
tmcCollectRows(reg[67],1,reg[66]);

tmcScalar(reg[69],2.000000000000000e+000);
tmcPower(reg[70],w1,reg[69]);
tmcDiv(reg[71],reg[67],reg[70]);

tmcAssign(num,reg[71]);
//statement here,line 8

// % Lines 9--9:
//den = [1, 2 * d2 * w2,  w2^2] / w2^2;

tmcScalar(reg[73],1.000000000000000e+000);
tmcScalar(reg[74],2.000000000000000e+000);

tmcMul(reg[76],reg[74],d2);

tmcMul(reg[78],reg[76],w2);

tmcScalar(reg[80],2.000000000000000e+000);
tmcPower(reg[81],w2,reg[80]);
tmcCollectColumns(reg[82],3,reg[73],reg[78],reg[81]);
tmcCollectRows(reg[83],1,reg[82]);

tmcScalar(reg[85],2.000000000000000e+000);
tmcPower(reg[86],w2,reg[85]);
tmcDiv(reg[87],reg[83],reg[86]);

tmcAssign(den,reg[87]);
//statement here,line 9

// % Lines 10--10:
label_1: ; //end Function
FINALLY
tmcFreeLocalVar(P);
tmcFreeLocalVar(s);
tmcFreeRegFrame(reg);

TMC_DBG_POP_STACK_VAR(11);

ENDFINALLY
}

//FUNCTION DEFINITION BEGIN
//statement here,line 10

// % Lines 11--11:
