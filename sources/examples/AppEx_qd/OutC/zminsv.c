//File: zminsv.c 
//Generated by TMC Converter(C)2009-2016
#include "tmc.h"
#include "stdtmc.h"

#include "TestO.globals.h"

// User provided C-code header (must be included in include path):
#include "External_func.h"

// % Lines 1--15:
//

//function [s,x] = zminsv(A,tol)

//%

//%  zminsv calculates the smallest singular value

//%  of matrix A and the associated right singular vector

//%  via an implicit inverse iteration in the form of the

//%  Gauss-Newton iteration

//%

//%    input  A --- the matrix

//%           tol --- the error tolerence

//%

//%   output  s --- the smallest singular value

//%           x --- the associated right singular vector

//%

//   [m,n] = size(A);      % get the dimensions of A

void tmczminsv(int nargout, int nargin,tmsMatrix *s,tmsMatrix *x
,tmsMatrix *A,tmsMatrix *tol) {
tmsMatrix **reg=tmcCreateRegFrame(215);
tmsMatrix *m=tmcNewMatrix();
tmsMatrix *n=tmcNewMatrix();
tmsMatrix *scale=tmcNewMatrix();
tmsMatrix *a=tmcNewMatrix();
tmsMatrix *b=tmcNewMatrix();
tmsMatrix *Q=tmcNewMatrix();
tmsMatrix *R=tmcNewMatrix();
tmsMatrix *T=tmcNewMatrix();
tmsMatrix *trans=tmcNewMatrix();
tmsMatrix *z=tmcNewMatrix();
tmsMatrix *r=tmcNewMatrix();
tmsMatrix *ss_=tmcNewMatrix();
tmsMatrix *cr=tmcNewMatrix();
tmsMatrix *k=tmcNewMatrix();
tmsMatrix *u=tmcNewMatrix();
tmsMatrix *y=tmcNewMatrix();

TRY
TMC_DBG_PUSH_STACK_VAR("zminsv",20,
A,"A",
tol,"tol",
s,"s",
x,"x",
m,"m",
n,"n",
scale,"scale",
a,"a",
b,"b",
Q,"Q",
R,"R",
T,"T",
trans,"trans",
z,"z",
r,"r",
ss_,"ss_",
cr,"cr",
k,"k",
u,"u",
y,"y");


//CALL function
tmcReallocRegister(reg[2]);
tmcReallocRegister(reg[3]);
tmcsize(2,1, reg[2], reg[3], A,NULL);

tmcAssign(m,reg[2]);

tmcAssign(n,reg[3]);
//statement here,line 15

// % Lines 16--16:
//   scale = norm(A,inf);  % get the magnitude of rows as scaler


//CALL function
tmcReallocRegister(reg[7]);
tmcinf(1,0, reg[7]);
//CALL function
tmcReallocRegister(reg[8]);
tmcnorm(1,2, reg[8], A, reg[7]);

tmcAssign(scale,reg[8]);
//statement here,line 16

// % Lines 17--18:
//   %TMC_DEBUG: a = 2*rand(1,n)-1;        % random initial vector

//   a = 2*ones(1,n)-1;

tmcScalar(reg[10],2.000000000000000e+000);
tmcScalar(reg[11],1.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[13]);
tmcones(1,2, reg[13], reg[11], n);
tmcMul(reg[14],reg[10],reg[13]);
tmcScalar(reg[15],1.000000000000000e+000);
tmcSub(reg[16],reg[14],reg[15]);

tmcAssign(a,reg[16]);
//statement here,line 18

// % Lines 19--20:
//   

//   a = scale*a/norm(a);      % set the first row



tmcMul(reg[20],scale,a);

//CALL function
tmcReallocRegister(reg[22]);
tmcnorm(1,1, reg[22], a,NULL);
tmcDiv(reg[23],reg[20],reg[22]);

tmcAssign(a,reg[23]);
//statement here,line 20

// % Lines 21--21:
//   b = [scale;zeros(m,1)];


tmcCollectColumns(reg[26],1,scale);

tmcScalar(reg[28],1.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[29]);
tmczeros(1,2, reg[29], m, reg[28]);
tmcCollectColumns(reg[30],1,reg[29]);
tmcCollectRows(reg[31],2,reg[26],reg[30]);

tmcAssign(b,reg[31]);
//statement here,line 21

// % Lines 22--23:
//   

//   [Q,R] = qr(A);              % QR decomp. of A, maybe input


//CALL function
tmcReallocRegister(reg[34]);
tmcReallocRegister(reg[35]);
tmcReallocRegister(reg[36]);
tmcqr(2,1, reg[34], reg[35], reg[36], A,NULL);

tmcAssign(Q,reg[34]);

tmcAssign(R,reg[35]);
//statement here,line 23

// % Lines 24--25:
//  

//   [T,trans] = hessqr([a;R]);  % Hessenberg QR decomp. of stacked matrix


tmcCollectColumns(reg[40],1,a);

tmcCollectColumns(reg[42],1,R);
tmcCollectRows(reg[43],2,reg[40],reg[42]);
//CALL function
tmcReallocRegister(reg[44]);
tmcReallocRegister(reg[45]);
tmchessqr(2,1, reg[44], reg[45], reg[43]);

tmcAssign(T,reg[44]);

tmcAssign(trans,reg[45]);
//statement here,line 25

// % Lines 26--26:
//   z = hqrt(trans,b);          % same Q on b



//CALL function
tmcReallocRegister(reg[50]);
tmchqrt(1,2, reg[50], trans, b);

tmcAssign(z,reg[50]);
//statement here,line 26

// % Lines 27--28:
//   

//   x = backsub(T(1:n,1:n),z(1:n));  x = x/norm(x); % geting the new vector


tmcScalar(reg[53],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[55],reg[53],n);
tmcScalar(reg[56],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[58],reg[56],n);
tmcGetByIndex(reg[59],T,2,reg[55],reg[58]);

tmcScalar(reg[61],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[63],reg[61],n);
tmcGetByIndex(reg[64],z,1,reg[63]);
//CALL function
tmcReallocRegister(reg[65]);
tmcbacksub(1,2, reg[65], reg[59], reg[64]);

tmcAssign(x,reg[65]);
//statement here,line 28



//CALL function
tmcReallocRegister(reg[69]);
tmcnorm(1,1, reg[69], x,NULL);
tmcDiv(reg[70],x,reg[69]);

tmcAssign(x,reg[70]);
//statement here,line 28

// % Lines 29--30:
//   

//   r = [scale*x';R]*x-b;



tmcTranspose(reg[74],x);
tmcMul(reg[75],scale,reg[74]);
tmcCollectColumns(reg[76],1,reg[75]);

tmcCollectColumns(reg[78],1,R);
tmcCollectRows(reg[79],2,reg[76],reg[78]);

tmcMul(reg[81],reg[79],x);

tmcSub(reg[83],reg[81],b);

tmcAssign(r,reg[83]);
//statement here,line 30

// % Lines 31--31:
//   ss_ = [norm(r(2:m+1))]; cr = [];


tmcScalar(reg[86],2.000000000000000e+000);

tmcScalar(reg[88],1.000000000000000e+000);
tmcAdd(reg[89],m,reg[88]);
tmcCreateColonBaseLimit(reg[90],reg[86],reg[89]);
tmcGetByIndex(reg[91],r,1,reg[90]);
//CALL function
tmcReallocRegister(reg[92]);
tmcnorm(1,1, reg[92], reg[91],NULL);
tmcCollectColumns(reg[93],1,reg[92]);
tmcCollectRows(reg[94],1,reg[93]);

tmcAssign(ss_,reg[94]);
//statement here,line 31

tmcCreateMatrixEmpty(reg[96]);

tmcAssign(cr,reg[96]);
//statement here,line 31

// % Lines 32--35:
//   

//   for k = 1:3

//       

//       [T,trans] = hessqr([2*scale*x';R]); 

tmcScalar(reg[98],1.000000000000000e+000);
tmcScalar(reg[99],3.000000000000000e+000);
tmcCreateColonBaseLimit(reg[100],reg[98],reg[99]);
tmcForIterInit(reg[101],reg[100],k);
label_4: ; //FOR begin
if(tmcForIterNext(reg[101],reg[100])) goto label_3; // exit for
tmcScalar(reg[102],2.000000000000000e+000);

tmcMul(reg[104],reg[102],scale);

tmcTranspose(reg[106],x);
tmcMul(reg[107],reg[104],reg[106]);
tmcCollectColumns(reg[108],1,reg[107]);

tmcCollectColumns(reg[110],1,R);
tmcCollectRows(reg[111],2,reg[108],reg[110]);
//CALL function
tmcReallocRegister(reg[112]);
tmcReallocRegister(reg[113]);
tmchessqr(2,1, reg[112], reg[113], reg[111]);

tmcAssign(T,reg[112]);

tmcAssign(trans,reg[113]);
//statement here,line 35

// % Lines 36--36:
//       z = hqrt(trans,r); 



//CALL function
tmcReallocRegister(reg[118]);
tmchqrt(1,2, reg[118], trans, r);

tmcAssign(z,reg[118]);
//statement here,line 36

// % Lines 37--37:
//       u = backsub(T(1:n,1:n),z(1:n));


tmcScalar(reg[121],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[123],reg[121],n);
tmcScalar(reg[124],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[126],reg[124],n);
tmcGetByIndex(reg[127],T,2,reg[123],reg[126]);

tmcScalar(reg[129],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[131],reg[129],n);
tmcGetByIndex(reg[132],z,1,reg[131]);
//CALL function
tmcReallocRegister(reg[133]);
tmcbacksub(1,2, reg[133], reg[127], reg[132]);

tmcAssign(u,reg[133]);
//statement here,line 37

// % Lines 38--38:
//       y = x - u;



tmcSub(reg[137],x,u);

tmcAssign(y,reg[137]);
//statement here,line 38

// % Lines 39--39:
//       y = y / norm(y);



//CALL function
tmcReallocRegister(reg[141]);
tmcnorm(1,1, reg[141], y,NULL);
tmcDiv(reg[142],y,reg[141]);

tmcAssign(y,reg[142]);
//statement here,line 39

// % Lines 40--40:
//       r = [scale*y';R]*y-b; 



tmcTranspose(reg[146],y);
tmcMul(reg[147],scale,reg[146]);
tmcCollectColumns(reg[148],1,reg[147]);

tmcCollectColumns(reg[150],1,R);
tmcCollectRows(reg[151],2,reg[148],reg[150]);

tmcMul(reg[153],reg[151],y);

tmcSub(reg[155],reg[153],b);

tmcAssign(r,reg[155]);
//statement here,line 40

// % Lines 41--41:
//       s = norm(r(2:m+1));


tmcScalar(reg[158],2.000000000000000e+000);

tmcScalar(reg[160],1.000000000000000e+000);
tmcAdd(reg[161],m,reg[160]);
tmcCreateColonBaseLimit(reg[162],reg[158],reg[161]);
tmcGetByIndex(reg[163],r,1,reg[162]);
//CALL function
tmcReallocRegister(reg[164]);
tmcnorm(1,1, reg[164], reg[163],NULL);

tmcAssign(s,reg[164]);
//statement here,line 41

// % Lines 42--42:
//       ss_ = [ss_,s];



tmcCollectColumns(reg[168],2,ss_,s);
tmcCollectRows(reg[169],1,reg[168]);

tmcAssign(ss_,reg[169]);
//statement here,line 42

// % Lines 43--43:
//       cr = [cr,norm(x-y)]; %disp(cr(k));




tmcSub(reg[174],x,y);
//CALL function
tmcReallocRegister(reg[175]);
tmcnorm(1,1, reg[175], reg[174],NULL);
tmcCollectColumns(reg[176],2,cr,reg[175]);
tmcCollectRows(reg[177],1,reg[176]);

tmcAssign(cr,reg[177]);
//statement here,line 43

// % Lines 44--46:
//      

//       if k == 1

//           if cr(1) < tol, break; end;


tmcScalar(reg[180],1.000000000000000e+000);
tmcEq(reg[181],k,reg[180]);
if(tmcIsFalse(reg[181])) goto label_6; // goto to the end of the clause if the expression is false

tmcScalar(reg[183],1.000000000000000e+000);
tmcGetByIndex(reg[184],cr,1,reg[183]);

tmcLt(reg[186],reg[184],tol);
if(tmcIsFalse(reg[186])) goto label_8; // goto to the end of the clause if the expression is false
goto label_3; //break to WHILE exit
//statement here,line 46

goto label_7; //branch to end IF
label_8: ; //end IF clause
label_7: ; //end IF
//statement here,line 46

// % Lines 47--50:
//       else

//           if cr(k) < cr(k-1)

//               if cr(k)^2/(cr(k-1)-cr(k))<tol 

//                   break

goto label_5; //branch to end IF
label_6: ; //end IF clause


tmcGetByIndex(reg[189],cr,1,k);


tmcScalar(reg[192],1.000000000000000e+000);
tmcSub(reg[193],k,reg[192]);
tmcGetByIndex(reg[194],cr,1,reg[193]);
tmcLt(reg[195],reg[189],reg[194]);
if(tmcIsFalse(reg[195])) goto label_11; // goto to the end of the clause if the expression is false


tmcGetByIndex(reg[198],cr,1,k);
tmcScalar(reg[199],2.000000000000000e+000);
tmcPower(reg[200],reg[198],reg[199]);


tmcScalar(reg[203],1.000000000000000e+000);
tmcSub(reg[204],k,reg[203]);
tmcGetByIndex(reg[205],cr,1,reg[204]);


tmcGetByIndex(reg[208],cr,1,k);
tmcSub(reg[209],reg[205],reg[208]);
tmcDiv(reg[210],reg[200],reg[209]);

tmcLt(reg[212],reg[210],tol);
if(tmcIsFalse(reg[212])) goto label_13; // goto to the end of the clause if the expression is false
goto label_3; //break to WHILE exit
//statement here,line 50

// % Lines 51--51:
//               end;

goto label_12; //branch to end IF
label_13: ; //end IF clause
label_12: ; //end IF
//statement here,line 51

// % Lines 52--52:
//           end;

goto label_10; //branch to end IF
label_11: ; //end IF clause
label_10: ; //end IF
//statement here,line 52

// % Lines 53--53:
//       end;

label_9: ; //end IF clause
label_5: ; //end IF
//statement here,line 53

// % Lines 54--54:
//       x = y;



tmcAssign(x,y);
//statement here,line 54

// % Lines 55--56:
//       

//   end;
label_2: ; //FOR end
goto label_4; //branch to FOR begin
label_3: ; //FOR exit
//statement here,line 56

label_1: ; //end Function
FINALLY
tmcFreeLocalVar(y);
tmcFreeLocalVar(u);
tmcFreeLocalVar(k);
tmcFreeLocalVar(cr);
tmcFreeLocalVar(ss_);
tmcFreeLocalVar(r);
tmcFreeLocalVar(z);
tmcFreeLocalVar(trans);
tmcFreeLocalVar(T);
tmcFreeLocalVar(R);
tmcFreeLocalVar(Q);
tmcFreeLocalVar(b);
tmcFreeLocalVar(a);
tmcFreeLocalVar(scale);
tmcFreeLocalVar(n);
tmcFreeLocalVar(m);
tmcFreeRegFrame(reg);

TMC_DBG_POP_STACK_VAR(20);

ENDFINALLY
}

//FUNCTION DEFINITION ENDED
//statement here,line 56

// % Lines 57--57:
