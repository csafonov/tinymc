//File: polyder.c 
//Generated by TMC Converter(C)2009-2016
#include "tmc.h"
#include "stdtmc.h"

#include "TestO.globals.h"

// User provided C-code header (must be included in include path):
#include "External_func.h"

// % Lines 1--17:
//function [a,b] = polyder(u,v)

//%POLYDER Differentiate polynomial.

//%   POLYDER(P) returns the derivative of the polynomial whose

//%   coefficients are the elements of vector P.

//%

//%   POLYDER(A,B) returns the derivative of polynomial A*B.

//%

//%   [Q,D] = POLYDER(B,A) returns the derivative of the

//%   polynomial ratio B/A, represented as Q/D.

//%

//%   See also POLYINT, CONV, DECONV.

//

//%   Charles R. Denham, MathWorks, 1988.

//%   Copyright 1984-2002 The MathWorks, Inc.

//%   $Revision: 5.11 $  $Date: 2002/04/09 00:14:25 $

//

//if nargin < 2, v = 1; end

void tmcpolyder(int nargout, int nargin,tmsMatrix *a,tmsMatrix *b
,tmsMatrix *u__input__tmc,tmsMatrix *v__input__tmc) {
tmsMatrix **reg=tmcCreateRegFrame(156);
tmsMatrix *u=tmcNewMatrix();
tmsMatrix *v=tmcNewMatrix();
tmsMatrix *nu=tmcNewMatrix();
tmsMatrix *nv=tmcNewMatrix();
tmsMatrix *up=tmcNewMatrix();
tmsMatrix *vp=tmcNewMatrix();
tmsMatrix *a1=tmcNewMatrix();
tmsMatrix *a2=tmcNewMatrix();
tmsMatrix *i_=tmcNewMatrix();
tmsMatrix *j_=tmcNewMatrix();
tmsMatrix *z=tmcNewMatrix();
tmsMatrix *f=tmcNewMatrix();

tmcCopyMat(u,u__input__tmc);
tmcCopyMat(v,v__input__tmc);
TRY
TMC_DBG_PUSH_STACK_VAR("polyder",16,
u__input__tmc,"u__input__tmc",
v__input__tmc,"v__input__tmc",
a,"a",
b,"b",
u,"u",
v,"v",
nu,"nu",
nv,"nv",
up,"up",
vp,"vp",
a1,"a1",
a2,"a2",
i_,"i_",
j_,"j_",
z,"z",
f,"f");

//CALL function
tmcReallocRegister(reg[1]);
tmcnargin(1,0, reg[1]);
tmcScalar(reg[2],2.000000000000000e+000);
tmcLt(reg[3],reg[1],reg[2]);
if(tmcIsFalse(reg[3])) goto label_3; // goto to the end of the clause if the expression is false
tmcScalar(reg[4],1.000000000000000e+000);

tmcAssign(v,reg[4]);
//statement here,line 17

goto label_2; //branch to end IF
label_3: ; //end IF clause
label_2: ; //end IF
//statement here,line 17

// % Lines 18--19:
//

//u = u(:).'; v = v(:).';


tmcCreateMagicColon(reg[7]);
tmcGetByIndex(reg[8],u,1,reg[7]);
tmcTransposeScalar(reg[9],reg[8]);

tmcAssign(u,reg[9]);
//statement here,line 19


tmcCreateMagicColon(reg[12]);
tmcGetByIndex(reg[13],v,1,reg[12]);
tmcTransposeScalar(reg[14],reg[13]);

tmcAssign(v,reg[14]);
//statement here,line 19

// % Lines 20--20:
//nu = length(u); nv = length(v);


//CALL function
tmcReallocRegister(reg[17]);
tmclength(1,1, reg[17], u);

tmcAssign(nu,reg[17]);
//statement here,line 20


//CALL function
tmcReallocRegister(reg[20]);
tmclength(1,1, reg[20], v);

tmcAssign(nv,reg[20]);
//statement here,line 20

// % Lines 21--21:
//if nu < 2, up = 0; else, up = u(1:nu-1) .* (nu-1:-1:1); end


tmcScalar(reg[23],2.000000000000000e+000);
tmcLt(reg[24],nu,reg[23]);
if(tmcIsFalse(reg[24])) goto label_5; // goto to the end of the clause if the expression is false
tmcScalar(reg[25],0.000000000000000e+000);

tmcAssign(up,reg[25]);
//statement here,line 21

goto label_4; //branch to end IF
label_5: ; //end IF clause

tmcScalar(reg[28],1.000000000000000e+000);

tmcScalar(reg[30],1.000000000000000e+000);
tmcSub(reg[31],nu,reg[30]);
tmcCreateColonBaseLimit(reg[32],reg[28],reg[31]);
tmcGetByIndex(reg[33],u,1,reg[32]);

tmcScalar(reg[35],1.000000000000000e+000);
tmcSub(reg[36],nu,reg[35]);
tmcScalar(reg[37],1.000000000000000e+000);
tmcScalar(reg[38],1.000000000000000e+000);
tmcNeg(reg[39],reg[38]);
tmcCreateColonBaseIncLimit(reg[40],reg[36],reg[39],reg[37]);
tmcMulScalar(reg[41],reg[33],reg[40]);

tmcAssign(up,reg[41]);
//statement here,line 21

label_6: ; //end IF clause
label_4: ; //end IF
//statement here,line 21

// % Lines 22--22:
//if nv < 2, vp = 0; else, vp = v(1:nv-1) .* (nv-1:-1:1); end


tmcScalar(reg[44],2.000000000000000e+000);
tmcLt(reg[45],nv,reg[44]);
if(tmcIsFalse(reg[45])) goto label_8; // goto to the end of the clause if the expression is false
tmcScalar(reg[46],0.000000000000000e+000);

tmcAssign(vp,reg[46]);
//statement here,line 22

goto label_7; //branch to end IF
label_8: ; //end IF clause

tmcScalar(reg[49],1.000000000000000e+000);

tmcScalar(reg[51],1.000000000000000e+000);
tmcSub(reg[52],nv,reg[51]);
tmcCreateColonBaseLimit(reg[53],reg[49],reg[52]);
tmcGetByIndex(reg[54],v,1,reg[53]);

tmcScalar(reg[56],1.000000000000000e+000);
tmcSub(reg[57],nv,reg[56]);
tmcScalar(reg[58],1.000000000000000e+000);
tmcScalar(reg[59],1.000000000000000e+000);
tmcNeg(reg[60],reg[59]);
tmcCreateColonBaseIncLimit(reg[61],reg[57],reg[60],reg[58]);
tmcMulScalar(reg[62],reg[54],reg[61]);

tmcAssign(vp,reg[62]);
//statement here,line 22

label_9: ; //end IF clause
label_7: ; //end IF
//statement here,line 22

// % Lines 23--23:
//a1 = conv(up,v); a2 = conv(u,vp);



//CALL function
tmcReallocRegister(reg[66]);
tmcconv(1,2, reg[66], up, v);

tmcAssign(a1,reg[66]);
//statement here,line 23



//CALL function
tmcReallocRegister(reg[70]);
tmcconv(1,2, reg[70], u, vp);

tmcAssign(a2,reg[70]);
//statement here,line 23

// % Lines 24--24:
//i_ = length(a1); j_ = length(a2); z = zeros(1,abs(i_-j_));


//CALL function
tmcReallocRegister(reg[73]);
tmclength(1,1, reg[73], a1);

tmcAssign(i_,reg[73]);
//statement here,line 24


//CALL function
tmcReallocRegister(reg[76]);
tmclength(1,1, reg[76], a2);

tmcAssign(j_,reg[76]);
//statement here,line 24

tmcScalar(reg[78],1.000000000000000e+000);


tmcSub(reg[81],i_,j_);
//CALL function
tmcReallocRegister(reg[82]);
tmcabs(1,1, reg[82], reg[81]);
//CALL function
tmcReallocRegister(reg[83]);
tmczeros(1,2, reg[83], reg[78], reg[82]);

tmcAssign(z,reg[83]);
//statement here,line 24

// % Lines 25--25:
//if i_ > j_, a2 = [z a2]; elseif i_ < j_, a1 = [z a1]; end



tmcGt(reg[87],i_,j_);
if(tmcIsFalse(reg[87])) goto label_11; // goto to the end of the clause if the expression is false


tmcCollectColumns(reg[90],2,z,a2);
tmcCollectRows(reg[91],1,reg[90]);

tmcAssign(a2,reg[91]);
//statement here,line 25

goto label_10; //branch to end IF
label_11: ; //end IF clause


tmcLt(reg[95],i_,j_);
if(tmcIsFalse(reg[95])) goto label_12; // goto to the end of the clause if the expression is false


tmcCollectColumns(reg[98],2,z,a1);
tmcCollectRows(reg[99],1,reg[98]);

tmcAssign(a1,reg[99]);
//statement here,line 25

goto label_10; //branch to end IF
label_12: ; //end IF clause
label_10: ; //end IF
//statement here,line 25

// % Lines 26--26:
//if nargout < 2, a = a1 + a2; else, a = a1 - a2; end

//CALL function
tmcReallocRegister(reg[101]);
tmcnargout(1,0, reg[101]);
tmcScalar(reg[102],2.000000000000000e+000);
tmcLt(reg[103],reg[101],reg[102]);
if(tmcIsFalse(reg[103])) goto label_14; // goto to the end of the clause if the expression is false


tmcAdd(reg[106],a1,a2);

tmcAssign(a,reg[106]);
//statement here,line 26

goto label_13; //branch to end IF
label_14: ; //end IF clause


tmcSub(reg[110],a1,a2);

tmcAssign(a,reg[110]);
//statement here,line 26

label_15: ; //end IF clause
label_13: ; //end IF
//statement here,line 26

// % Lines 27--27:
//f = find(a ~= 0);


tmcScalar(reg[113],0.000000000000000e+000);
tmcNe(reg[114],a,reg[113]);
//CALL function
tmcReallocRegister(reg[115]);
tmcReallocRegister(reg[116]);
tmcReallocRegister(reg[117]);
tmcfind(1,1, reg[115], reg[116], reg[117], reg[114],NULL,NULL);

tmcAssign(f,reg[115]);
//statement here,line 27

// % Lines 28--28:
//if ~isempty(f), a = a(f(1):end); else, a = 0; end


//CALL function
tmcReallocRegister(reg[120]);
tmcisempty(1,1, reg[120], f);
tmcNot(reg[121],reg[120]);
if(tmcIsFalse(reg[121])) goto label_17; // goto to the end of the clause if the expression is false


tmcScalar(reg[124],1.000000000000000e+000);
tmcGetByIndex(reg[125],f,1,reg[124]);
tmcGetEnd(reg[126],a,1,1);
tmcCreateColonBaseLimit(reg[127],reg[125],reg[126]);
tmcGetByIndex(reg[128],a,1,reg[127]);

tmcAssign(a,reg[128]);
//statement here,line 28

goto label_16; //branch to end IF
label_17: ; //end IF clause
tmcScalar(reg[130],0.000000000000000e+000);

tmcAssign(a,reg[130]);
//statement here,line 28

label_18: ; //end IF clause
label_16: ; //end IF
//statement here,line 28

// % Lines 29--29:
//b = conv(v,v);



//CALL function
tmcReallocRegister(reg[134]);
tmcconv(1,2, reg[134], v, v);

tmcAssign(b,reg[134]);
//statement here,line 29

// % Lines 30--30:
//f = find(b ~= 0);


tmcScalar(reg[137],0.000000000000000e+000);
tmcNe(reg[138],b,reg[137]);
//CALL function
tmcReallocRegister(reg[139]);
tmcReallocRegister(reg[140]);
tmcReallocRegister(reg[141]);
tmcfind(1,1, reg[139], reg[140], reg[141], reg[138],NULL,NULL);

tmcAssign(f,reg[139]);
//statement here,line 30

// % Lines 31--31:
//if ~isempty(f), b = b(f(1):end); else, b = 0; end


//CALL function
tmcReallocRegister(reg[144]);
tmcisempty(1,1, reg[144], f);
tmcNot(reg[145],reg[144]);
if(tmcIsFalse(reg[145])) goto label_20; // goto to the end of the clause if the expression is false


tmcScalar(reg[148],1.000000000000000e+000);
tmcGetByIndex(reg[149],f,1,reg[148]);
tmcGetEnd(reg[150],b,1,1);
tmcCreateColonBaseLimit(reg[151],reg[149],reg[150]);
tmcGetByIndex(reg[152],b,1,reg[151]);

tmcAssign(b,reg[152]);
//statement here,line 31

goto label_19; //branch to end IF
label_20: ; //end IF clause
tmcScalar(reg[154],0.000000000000000e+000);

tmcAssign(b,reg[154]);
//statement here,line 31

label_21: ; //end IF clause
label_19: ; //end IF
//statement here,line 31

// % Lines 32--32:
label_1: ; //end Function
FINALLY
tmcFreeLocalVar(f);
tmcFreeLocalVar(z);
tmcFreeLocalVar(j_);
tmcFreeLocalVar(i_);
tmcFreeLocalVar(a2);
tmcFreeLocalVar(a1);
tmcFreeLocalVar(vp);
tmcFreeLocalVar(up);
tmcFreeLocalVar(nv);
tmcFreeLocalVar(nu);
tmcFreeLocalVar(v);
tmcFreeLocalVar(u);
tmcFreeRegFrame(reg);

TMC_DBG_POP_STACK_VAR(16);

ENDFINALLY
}

//FUNCTION DEFINITION ENDED
//statement here,line 32

// % Lines 33--33:
