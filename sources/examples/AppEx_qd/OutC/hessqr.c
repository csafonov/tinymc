//File: hessqr.c 
//Generated by TMC Converter(C)2009-2016
#include "tmc.h"
#include "stdtmc.h"

#include "TestO.globals.h"

// User provided C-code header (must be included in include path):
#include "External_func.h"

// % Lines 1--11:
//

//function [B,t] = hessqr(A)

//%

//%  hessqr performs QR decomposition on an upper

//%      Hessenberg matrix

//%

//%  assume A is a Hessenberg matrix

//%  output  B -- upper triangular

//%          c -- rotation used

//%

//   [m,n] = size(A);

void tmchessqr(int nargout, int nargin,tmsMatrix *B,tmsMatrix *t
,tmsMatrix *A) {
tmsMatrix **reg=tmcCreateRegFrame(100);
tmsMatrix *m=tmcNewMatrix();
tmsMatrix *n=tmcNewMatrix();
tmsMatrix *j_=tmcNewMatrix();
tmsMatrix *d=tmcNewMatrix();
tmsMatrix *c=tmcNewMatrix();
tmsMatrix *s=tmcNewMatrix();
tmsMatrix *T=tmcNewMatrix();

TRY
TMC_DBG_PUSH_STACK_VAR("hessqr",10,
A,"A",
B,"B",
t,"t",
m,"m",
n,"n",
j_,"j_",
d,"d",
c,"c",
s,"s",
T,"T");


//CALL function
tmcReallocRegister(reg[2]);
tmcReallocRegister(reg[3]);
tmcsize(2,1, reg[2], reg[3], A,NULL);

tmcAssign(m,reg[2]);

tmcAssign(n,reg[3]);
//statement here,line 11

// % Lines 12--12:
//   if m < n, return; end;



tmcLt(reg[8],m,n);
if(tmcIsFalse(reg[8])) goto label_3; // goto to the end of the clause if the expression is false
goto label_1; //branch to FUNCTION exit
//statement here,line 12

goto label_2; //branch to end IF
label_3: ; //end IF clause
label_2: ; //end IF
//statement here,line 12

// % Lines 13--14:
//   

//   B = A;



tmcAssign(B,A);
//statement here,line 14

// % Lines 15--18:
//   

//   for j_ = 1:n

//       if j_ < m

//           d = sqrt(B(j_,j_)^2+B(j_+1,j_)^2);

tmcScalar(reg[11],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[13],reg[11],n);
tmcForIterInit(reg[14],reg[13],j_);
label_6: ; //FOR begin
if(tmcForIterNext(reg[14],reg[13])) goto label_5; // exit for


tmcLt(reg[17],j_,m);
if(tmcIsFalse(reg[17])) goto label_8; // goto to the end of the clause if the expression is false



tmcGetByIndex(reg[21],B,2,j_,j_);
tmcScalar(reg[22],2.000000000000000e+000);
tmcPower(reg[23],reg[21],reg[22]);


tmcScalar(reg[26],1.000000000000000e+000);
tmcAdd(reg[27],j_,reg[26]);

tmcGetByIndex(reg[29],B,2,reg[27],j_);
tmcScalar(reg[30],2.000000000000000e+000);
tmcPower(reg[31],reg[29],reg[30]);
tmcAdd(reg[32],reg[23],reg[31]);
//CALL function
tmcReallocRegister(reg[33]);
tmcsqrt(1,1, reg[33], reg[32]);

tmcAssign(d,reg[33]);
//statement here,line 18

// % Lines 19--20:
//           if d ~= 0

//               c = B(j_,j_)/d; s = B(j_+1,j_)/d;


tmcScalar(reg[36],0.000000000000000e+000);
tmcNe(reg[37],d,reg[36]);
if(tmcIsFalse(reg[37])) goto label_10; // goto to the end of the clause if the expression is false



tmcGetByIndex(reg[41],B,2,j_,j_);

tmcDiv(reg[43],reg[41],d);

tmcAssign(c,reg[43]);
//statement here,line 20



tmcScalar(reg[47],1.000000000000000e+000);
tmcAdd(reg[48],j_,reg[47]);

tmcGetByIndex(reg[50],B,2,reg[48],j_);

tmcDiv(reg[52],reg[50],d);

tmcAssign(s,reg[52]);
//statement here,line 20

// % Lines 21--21:
//               T = [c,s;-s,c];



tmcCollectColumns(reg[56],2,c,s);

tmcNeg(reg[58],s);

tmcCollectColumns(reg[60],2,reg[58],c);
tmcCollectRows(reg[61],2,reg[56],reg[60]);

tmcAssign(T,reg[61]);
//statement here,line 21

// % Lines 22--22:
//               B(j_:j_+1,j_:n) = T*B(j_:j_+1,j_:n);





tmcScalar(reg[67],1.000000000000000e+000);
tmcAdd(reg[68],j_,reg[67]);
tmcCreateColonBaseLimit(reg[69],j_,reg[68]);


tmcCreateColonBaseLimit(reg[72],j_,n);
tmcGetByIndex(reg[73],B,2,reg[69],reg[72]);
tmcMul(reg[74],T,reg[73]);



tmcScalar(reg[78],1.000000000000000e+000);
tmcAdd(reg[79],j_,reg[78]);
tmcCreateColonBaseLimit(reg[80],j_,reg[79]);


tmcCreateColonBaseLimit(reg[83],j_,n);
tmcGetRefByIndex(pRefHelper,B,2,reg[80],reg[83]);
tmcAssign(pRefHelper,reg[74]);
//statement here,line 22

// % Lines 23--23:
//               t(1,j_) = c; t(2,j_) = s;



tmcScalar(reg[86],1.000000000000000e+000);

tmcGetRefByIndex(pRefHelper,t,2,reg[86],j_);
tmcAssign(pRefHelper,c);
//statement here,line 23



tmcScalar(reg[90],2.000000000000000e+000);

tmcGetRefByIndex(pRefHelper,t,2,reg[90],j_);
tmcAssign(pRefHelper,s);
//statement here,line 23

// % Lines 24--25:
//           else

//               t(1,j_) = 1; t(2,j_) = 0;

goto label_9; //branch to end IF
label_10: ; //end IF clause
tmcScalar(reg[92],1.000000000000000e+000);

tmcScalar(reg[94],1.000000000000000e+000);

tmcGetRefByIndex(pRefHelper,t,2,reg[94],j_);
tmcAssign(pRefHelper,reg[92]);
//statement here,line 25

tmcScalar(reg[96],0.000000000000000e+000);

tmcScalar(reg[98],2.000000000000000e+000);

tmcGetRefByIndex(pRefHelper,t,2,reg[98],j_);
tmcAssign(pRefHelper,reg[96]);
//statement here,line 25

// % Lines 26--26:
//           end;

label_11: ; //end IF clause
label_9: ; //end IF
//statement here,line 26

// % Lines 27--27:
//       end;

goto label_7; //branch to end IF
label_8: ; //end IF clause
label_7: ; //end IF
//statement here,line 27

// % Lines 28--28:
//   end;
label_4: ; //FOR end
goto label_6; //branch to FOR begin
label_5: ; //FOR exit
//statement here,line 28

label_1: ; //end Function
FINALLY
tmcFreeLocalVar(T);
tmcFreeLocalVar(s);
tmcFreeLocalVar(c);
tmcFreeLocalVar(d);
tmcFreeLocalVar(j_);
tmcFreeLocalVar(n);
tmcFreeLocalVar(m);
tmcFreeRegFrame(reg);

TMC_DBG_POP_STACK_VAR(10);

ENDFINALLY
}

//FUNCTION DEFINITION ENDED
//statement here,line 28

// % Lines 29--29:
