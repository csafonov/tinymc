//File: multroot.c 
//Generated by TMC Converter(C)2009-2016
#include "tmc.h"
#include "stdtmc.h"

#include "TestO.globals.h"

// User provided C-code header (must be included in include path):
#include "External_func.h"

// % Lines 1--29:
//function z = multroot( p, tol )

//%  

//%  Finds all roots of a real or complex polynomial p,

//% 

//%        p(x) = a_1 x^n + a_2 x^n-1 + ... + a_n x + a_n+1,

//%

//%  given by an (n+1)-row vector p = (a_1, ..., a_n+1) 

//%

//%  METHOD : for details, contact the author 

//%

//%             Zhonggang Zeng

//%             Department of Mathematics

//%             Northeastern Illinois University

//%             Chicago, IL 60625

//%          

//%             email: zzeng@neiu.edu

//%

//% This code is freely released for research exchange only. The author 

//% is not responsible for any demage caused by using this code.

//%

//%  INPUT :  p = polynomial coefficients. 

//%           

//%  OUTPUT : z = roots of polynomial p and multiplicities:

//%                  z(:,1) = all distinct roots

//%                  z(:,2) = corresponding multiplicities

//%  CALL :   

//%               >> z = multroot(p). 

//%

//   if nargin == 1, tol = 1.0d-10; end;

void tmcmultroot(int nargout, int nargin,tmsMatrix *z
,tmsMatrix *p__input__tmc,tmsMatrix *tol__input__tmc) {
tmsMatrix **reg=tmcCreateRegFrame(214);
tmsMatrix *p=tmcNewMatrix();
tmsMatrix *tol=tmcNewMatrix();
tmsMatrix *m=tmcNewMatrix();
tmsMatrix *n=tmcNewMatrix();
tmsMatrix *q=tmcNewMatrix();
tmsMatrix *jj=tmcNewMatrix();
tmsMatrix *j1=tmcNewMatrix();
tmsMatrix *j2=tmcNewMatrix();
tmsMatrix *c=tmcNewMatrix();
tmsMatrix *y=tmcNewMatrix();
tmsMatrix *bke=tmcNewMatrix();
tmsMatrix *bkerr=tmcNewMatrix();
tmsMatrix *pjcnd=tmcNewMatrix();
tmsMatrix *job=tmcNewMatrix();

tmcCopyMat(p,p__input__tmc);
tmcCopyMat(tol,tol__input__tmc);
TRY
TMC_DBG_PUSH_STACK_VAR("multroot",17,
p__input__tmc,"p__input__tmc",
tol__input__tmc,"tol__input__tmc",
z,"z",
p,"p",
tol,"tol",
m,"m",
n,"n",
q,"q",
jj,"jj",
j1,"j1",
j2,"j2",
c,"c",
y,"y",
bke,"bke",
bkerr,"bkerr",
pjcnd,"pjcnd",
job,"job");

//CALL function
tmcReallocRegister(reg[1]);
tmcnargin(1,0, reg[1]);
tmcScalar(reg[2],1.000000000000000e+000);
tmcEq(reg[3],reg[1],reg[2]);
if(tmcIsFalse(reg[3])) goto label_3; // goto to the end of the clause if the expression is false
tmcScalar(reg[4],1.000000000000000e-010);

tmcAssign(tol,reg[4]);
//statement here,line 29

goto label_2; //branch to end IF
label_3: ; //end IF clause
label_2: ; //end IF
//statement here,line 29

// % Lines 30--33:
//   %

//   % transpose if p is a column vector

//   %

//   [m,n] = size(p);            


//CALL function
tmcReallocRegister(reg[7]);
tmcReallocRegister(reg[8]);
tmcsize(2,1, reg[7], reg[8], p,NULL);

tmcAssign(m,reg[7]);

tmcAssign(n,reg[8]);
//statement here,line 33

// % Lines 34--34:
//   if m > n, p = p'; end;



tmcGt(reg[13],m,n);
if(tmcIsFalse(reg[13])) goto label_5; // goto to the end of the clause if the expression is false

tmcTranspose(reg[15],p);

tmcAssign(p,reg[15]);
//statement here,line 34

goto label_4; //branch to end IF
label_5: ; //end IF clause
label_4: ; //end IF
//statement here,line 34

// % Lines 35--38:
//   %

//   % clear leading/trailing zeros

//   %

//   n = length(p);


//CALL function
tmcReallocRegister(reg[18]);
tmclength(1,1, reg[18], p);

tmcAssign(n,reg[18]);
//statement here,line 38

// % Lines 39--39:
//   q = p;



tmcAssign(q,p);
//statement here,line 39

// % Lines 40--41:
//   if q(1) == 0 | q(n) == 0 

//       jj = find(p); 


tmcScalar(reg[23],1.000000000000000e+000);
tmcGetByIndex(reg[24],q,1,reg[23]);
tmcScalar(reg[25],0.000000000000000e+000);
tmcEq(reg[26],reg[24],reg[25]);


tmcGetByIndex(reg[29],q,1,n);
tmcScalar(reg[30],0.000000000000000e+000);
tmcEq(reg[31],reg[29],reg[30]);
tmcOrScalar(reg[32],reg[26],reg[31]);
if(tmcIsFalse(reg[32])) goto label_7; // goto to the end of the clause if the expression is false

//CALL function
tmcReallocRegister(reg[34]);
tmcReallocRegister(reg[35]);
tmcReallocRegister(reg[36]);
tmcfind(1,1, reg[34], reg[35], reg[36], p,NULL,NULL);

tmcAssign(jj,reg[34]);
//statement here,line 41

// % Lines 42--42:
//       j1 = min(jj); j2 = max(jj);


//CALL function
tmcReallocRegister(reg[39]);
tmcReallocRegister(reg[40]);
tmcmin(1,1, reg[39], reg[40], jj,NULL,NULL);

tmcAssign(j1,reg[39]);
//statement here,line 42


//CALL function
tmcReallocRegister(reg[43]);
tmcReallocRegister(reg[44]);
tmcmax(1,1, reg[43], reg[44], jj,NULL,NULL);

tmcAssign(j2,reg[43]);
//statement here,line 42

// % Lines 43--43:
//       q = p(j1:j2);




tmcCreateColonBaseLimit(reg[49],j1,j2);
tmcGetByIndex(reg[50],p,1,reg[49]);

tmcAssign(q,reg[50]);
//statement here,line 43

// % Lines 44--45:
//   else

//       j1 = 1; j2 = n;

goto label_6; //branch to end IF
label_7: ; //end IF clause
tmcScalar(reg[52],1.000000000000000e+000);

tmcAssign(j1,reg[52]);
//statement here,line 45



tmcAssign(j2,n);
//statement here,line 45

// % Lines 46--46:
//   end;

label_8: ; //end IF clause
label_6: ; //end IF
//statement here,line 46

// % Lines 47--47:
//   q = q/q(1); c = 1;



tmcScalar(reg[58],1.000000000000000e+000);
tmcGetByIndex(reg[59],q,1,reg[58]);
tmcDiv(reg[60],q,reg[59]);

tmcAssign(q,reg[60]);
//statement here,line 47

tmcScalar(reg[62],1.000000000000000e+000);

tmcAssign(c,reg[62]);
//statement here,line 47

// % Lines 48--51:
//   %

//   % scaling

//   %

//   m = length(q)-1;


//CALL function
tmcReallocRegister(reg[65]);
tmclength(1,1, reg[65], q);
tmcScalar(reg[66],1.000000000000000e+000);
tmcSub(reg[67],reg[65],reg[66]);

tmcAssign(m,reg[67]);
//statement here,line 51

// % Lines 52--52:
//   c = 1/(abs(q(m+1)))^(1/m);

tmcScalar(reg[69],1.000000000000000e+000);


tmcScalar(reg[72],1.000000000000000e+000);
tmcAdd(reg[73],m,reg[72]);
tmcGetByIndex(reg[74],q,1,reg[73]);
//CALL function
tmcReallocRegister(reg[75]);
tmcabs(1,1, reg[75], reg[74]);
tmcScalar(reg[76],1.000000000000000e+000);

tmcDiv(reg[78],reg[76],m);
tmcPower(reg[79],reg[75],reg[78]);
tmcDiv(reg[80],reg[69],reg[79]);

tmcAssign(c,reg[80]);
//statement here,line 52

// % Lines 53--53:
//   q = q.*(c.^[0:m]);



tmcScalar(reg[84],0.000000000000000e+000);

tmcCreateColonBaseLimit(reg[86],reg[84],m);
tmcCollectColumns(reg[87],1,reg[86]);
tmcCollectRows(reg[88],1,reg[87]);
tmcPowerScalar(reg[89],c,reg[88]);
tmcMulScalar(reg[90],q,reg[89]);

tmcAssign(q,reg[90]);
//statement here,line 53

// % Lines 54--55:
//   %

//   [y,bke] = gcdroot(q, tol);



//CALL function
tmcReallocRegister(reg[94]);
tmcReallocRegister(reg[95]);
tmcgcdroot(2,2, reg[94], reg[95], q, tol);

tmcAssign(y,reg[94]);

tmcAssign(bke,reg[95]);
//statement here,line 55

// % Lines 56--58:
//   

//   if bke < 1.0d-2

//       [z,bkerr,pjcnd,job] = pejroot(q,y(:,1).',y(:,2)');


tmcScalar(reg[99],1.000000000000000e-002);
tmcLt(reg[100],bke,reg[99]);
if(tmcIsFalse(reg[100])) goto label_10; // goto to the end of the clause if the expression is false


tmcCreateMagicColon(reg[103]);
tmcScalar(reg[104],1.000000000000000e+000);
tmcGetByIndex(reg[105],y,2,reg[103],reg[104]);
tmcTransposeScalar(reg[106],reg[105]);

tmcCreateMagicColon(reg[108]);
tmcScalar(reg[109],2.000000000000000e+000);
tmcGetByIndex(reg[110],y,2,reg[108],reg[109]);
tmcTranspose(reg[111],reg[110]);
//CALL function
tmcReallocRegister(reg[112]);
tmcReallocRegister(reg[113]);
tmcReallocRegister(reg[114]);
tmcReallocRegister(reg[115]);
tmcpejroot(4,3, reg[112], reg[113], reg[114], reg[115], q, reg[106], reg[111],NULL,NULL,NULL,NULL);

tmcAssign(z,reg[112]);

tmcAssign(bkerr,reg[113]);

tmcAssign(pjcnd,reg[114]);

tmcAssign(job,reg[115]);
//statement here,line 58

// % Lines 59--60:
//       if j2 < n

//           z = [z;0,n-j2];



tmcLt(reg[122],j2,n);
if(tmcIsFalse(reg[122])) goto label_12; // goto to the end of the clause if the expression is false

tmcCollectColumns(reg[124],1,z);
tmcScalar(reg[125],0.000000000000000e+000);


tmcSub(reg[128],n,j2);
tmcCollectColumns(reg[129],2,reg[125],reg[128]);
tmcCollectRows(reg[130],2,reg[124],reg[129]);

tmcAssign(z,reg[130]);
//statement here,line 60

// % Lines 61--61:
//       end;

goto label_11; //branch to end IF
label_12: ; //end IF clause
label_11: ; //end IF
//statement here,line 61

// % Lines 62--66:
//       if job == 1

//           %

//           % show off results

//           %

//           z(:,1) = z(:,1)/c;


tmcScalar(reg[133],1.000000000000000e+000);
tmcEq(reg[134],job,reg[133]);
if(tmcIsFalse(reg[134])) goto label_14; // goto to the end of the clause if the expression is false

tmcCreateMagicColon(reg[136]);
tmcScalar(reg[137],1.000000000000000e+000);
tmcGetByIndex(reg[138],z,2,reg[136],reg[137]);

tmcDiv(reg[140],reg[138],c);

tmcCreateMagicColon(reg[142]);
tmcScalar(reg[143],1.000000000000000e+000);
tmcGetRefByIndex(pRefHelper,z,2,reg[142],reg[143]);
tmcAssign(pRefHelper,reg[140]);
//statement here,line 66

// % Lines 67--67:
//           fprintf('\n');

tmcCreateString(reg[144],"\\n");
//CALL function
tmcfprintf(0,1, reg[144]);
//statement here,line 67

// % Lines 68--68:
//           fprintf('    !!!THE COMPUTATION IS SUCCESSFUL!!!\n');

tmcCreateString(reg[145],"    !!!THE COMPUTATION IS SUCCESSFUL!!!\\n");
//CALL function
tmcfprintf(0,1, reg[145]);
//statement here,line 68

// % Lines 69--69:
//           fprintf('\n');

tmcCreateString(reg[146],"\\n");
//CALL function
tmcfprintf(0,1, reg[146]);
//statement here,line 69

// % Lines 70--70:
//           fprintf('THE PEJORATIVE CONDITION NUMBER:     \t\t\t\t  %g \n',pjcnd);

tmcCreateString(reg[147],"THE PEJORATIVE CONDITION NUMBER:     \\t\\t\\t\\t  %g \\n");

//CALL function
tmcfprintf(0,2, reg[147], pjcnd);
//statement here,line 70

// % Lines 71--71:
//           fprintf('THE BACKWARD ERROR:                    %6.2e \n',bkerr);

tmcCreateString(reg[149],"THE BACKWARD ERROR:                    %6.2e \\n");

//CALL function
tmcfprintf(0,2, reg[149], bkerr);
//statement here,line 71

// % Lines 72--73:
//           fprintf('THE ESTIMATED FORWARD ROOT ERROR:      %6.2e \n',...

//               2*bkerr*pjcnd);

tmcCreateString(reg[151],"THE ESTIMATED FORWARD ROOT ERROR:      %6.2e \\n");
tmcScalar(reg[152],2.000000000000000e+000);

tmcMul(reg[154],reg[152],bkerr);

tmcMul(reg[156],reg[154],pjcnd);
//CALL function
tmcfprintf(0,2, reg[151], reg[156]);
//statement here,line 73

// % Lines 74--74:
//           fprintf('\n');

tmcCreateString(reg[157],"\\n");
//CALL function
tmcfprintf(0,1, reg[157]);
//statement here,line 74

// % Lines 75--76:
//           if norm(imag(z(:,1))) == 0 

//               fprintf('        computed roots         multiplicities\n');


tmcCreateMagicColon(reg[159]);
tmcScalar(reg[160],1.000000000000000e+000);
tmcGetByIndex(reg[161],z,2,reg[159],reg[160]);
//CALL function
tmcReallocRegister(reg[162]);
tmcimag(1,1, reg[162], reg[161]);
//CALL function
tmcReallocRegister(reg[163]);
tmcnorm(1,1, reg[163], reg[162],NULL);
tmcScalar(reg[164],0.000000000000000e+000);
tmcEq(reg[165],reg[163],reg[164]);
if(tmcIsFalse(reg[165])) goto label_16; // goto to the end of the clause if the expression is false
tmcCreateString(reg[166],"        computed roots         multiplicities\\n");
//CALL function
tmcfprintf(0,1, reg[166]);
//statement here,line 76

// % Lines 77--77:
//               fprintf('\n');

tmcCreateString(reg[167],"\\n");
//CALL function
tmcfprintf(0,1, reg[167]);
//statement here,line 77

// % Lines 78--78:
//               fprintf('%25.15f \t \t \t %3g \n', z');

tmcCreateString(reg[168],"%25.15f \\t \\t \\t %3g \\n");

tmcTranspose(reg[170],z);
//CALL function
tmcfprintf(0,2, reg[168], reg[170]);
//statement here,line 78

// % Lines 79--80:
//           else

//               fprintf('        computed roots ')

goto label_15; //branch to end IF
label_16: ; //end IF clause
tmcCreateString(reg[171],"        computed roots ");
//CALL function
tmcfprintf(0,1, reg[171]);
//statement here,line 80

// % Lines 81--81:
//               fprintf('   \t\t\t\t\t\t     multiplicities\n');

tmcCreateString(reg[172],"   \\t\\t\\t\\t\\t\\t     multiplicities\\n");
//CALL function
tmcfprintf(0,1, reg[172]);
//statement here,line 81

// % Lines 82--82:
//               fprintf('\n');

tmcCreateString(reg[173],"\\n");
//CALL function
tmcfprintf(0,1, reg[173]);
//statement here,line 82

// % Lines 83--84:
//               fprintf('%22.15f + %22.15f i \t \t %3g \n', ...

//                   [real(z(:,1)),imag(z(:,1)),z(:,2)]');

tmcCreateString(reg[174],"%22.15f + %22.15f i \\t \\t %3g \\n");

tmcCreateMagicColon(reg[176]);
tmcScalar(reg[177],1.000000000000000e+000);
tmcGetByIndex(reg[178],z,2,reg[176],reg[177]);
//CALL function
tmcReallocRegister(reg[179]);
tmcreal(1,1, reg[179], reg[178]);

tmcCreateMagicColon(reg[181]);
tmcScalar(reg[182],1.000000000000000e+000);
tmcGetByIndex(reg[183],z,2,reg[181],reg[182]);
//CALL function
tmcReallocRegister(reg[184]);
tmcimag(1,1, reg[184], reg[183]);

tmcCreateMagicColon(reg[186]);
tmcScalar(reg[187],2.000000000000000e+000);
tmcGetByIndex(reg[188],z,2,reg[186],reg[187]);
tmcCollectColumns(reg[189],3,reg[179],reg[184],reg[188]);
tmcCollectRows(reg[190],1,reg[189]);
tmcTranspose(reg[191],reg[190]);
//CALL function
tmcfprintf(0,2, reg[174], reg[191]);
//statement here,line 84

// % Lines 85--85:
//           end;

label_17: ; //end IF clause
label_15: ; //end IF
//statement here,line 85

// % Lines 86--87:
//       else

//           z = [roots(p),ones(length(p)-1,1)];

goto label_13; //branch to end IF
label_14: ; //end IF clause

//CALL function
tmcReallocRegister(reg[193]);
tmcroots(1,1, reg[193], p);

//CALL function
tmcReallocRegister(reg[195]);
tmclength(1,1, reg[195], p);
tmcScalar(reg[196],1.000000000000000e+000);
tmcSub(reg[197],reg[195],reg[196]);
tmcScalar(reg[198],1.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[199]);
tmcones(1,2, reg[199], reg[197], reg[198]);
tmcCollectColumns(reg[200],2,reg[193],reg[199]);
tmcCollectRows(reg[201],1,reg[200]);

tmcAssign(z,reg[201]);
//statement here,line 87

// % Lines 88--88:
//       end;

label_18: ; //end IF clause
label_13: ; //end IF
//statement here,line 88

// % Lines 89--90:
//   else

//       z = [roots(p),ones(length(p)-1,1)];

goto label_9; //branch to end IF
label_10: ; //end IF clause

//CALL function
tmcReallocRegister(reg[204]);
tmcroots(1,1, reg[204], p);

//CALL function
tmcReallocRegister(reg[206]);
tmclength(1,1, reg[206], p);
tmcScalar(reg[207],1.000000000000000e+000);
tmcSub(reg[208],reg[206],reg[207]);
tmcScalar(reg[209],1.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[210]);
tmcones(1,2, reg[210], reg[208], reg[209]);
tmcCollectColumns(reg[211],2,reg[204],reg[210]);
tmcCollectRows(reg[212],1,reg[211]);

tmcAssign(z,reg[212]);
//statement here,line 90

// % Lines 91--91:
//   end;

label_19: ; //end IF clause
label_9: ; //end IF
//statement here,line 91

// % Lines 92--92:
//   
label_1: ; //end Function
FINALLY
tmcFreeLocalVar(job);
tmcFreeLocalVar(pjcnd);
tmcFreeLocalVar(bkerr);
tmcFreeLocalVar(bke);
tmcFreeLocalVar(y);
tmcFreeLocalVar(c);
tmcFreeLocalVar(j2);
tmcFreeLocalVar(j1);
tmcFreeLocalVar(jj);
tmcFreeLocalVar(q);
tmcFreeLocalVar(n);
tmcFreeLocalVar(m);
tmcFreeLocalVar(tol);
tmcFreeLocalVar(p);
tmcFreeRegFrame(reg);

TMC_DBG_POP_STACK_VAR(17);

ENDFINALLY
}

//FUNCTION DEFINITION ENDED
//statement here,line 92

// % Lines 93--93:
