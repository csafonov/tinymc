//File: pejroot.c 
//Generated by TMC Converter(C)2009-2016
#include "tmc.h"
#include "stdtmc.h"

#include "TestO.globals.h"

// User provided C-code header (must be included in include path):
#include "External_func.h"

// % Lines 1--73:
//function [y, bkerr, pjcnd, job ] = ...

//              pejroot( f, y0, l, noi, tol, style, prtsty )

//%

//% PEJROOT calculates (multiple) roots of polynomial using an iterative

//% method developed by Z. Zeng. For details, you can request the paper

//%

//%     "Conputing Multiple roots of polynomials: pejorative condition and accurate

//%     computation", by Zhonggang Zeng 

//%

//% This code is dated Dec. 4, 2002. Please sent bug/failure report to

//%           

//%             Prof. Zhonggang Zeng

//%             Department of Mathematics

//%             Northeastern Illinois University

//%             Chicago, IL 60625

//%

//%             email: zzeng@neiu.edu

//%

//% This code is freely released for research exchange only. The author 

//% is not responsible for any demage caused by using this code.

//%

//% Calling syntax: The simplest way to call is

//%  

//%   » pejroot(f,y,m)

//%

//% where the input items are

//%          f --- (row vector) the target polynomial

//%          y --- (row vector) the initial iterate (of the roots)

//%          m --- (row vector) the multiplicity structure

//%

//% For more advanced usage:

//%

//%	» [z, e, c] = pejroot(f, y, l, noi, tol, style, prtsty)

//%

//% The output 

//%          z --- (matrix) distinct roots (1st column) and corresponding

//%                         multiplicities (2nd column)

//%          e --- (scalar) the backward error of the roots

//%          c --- (scalar) the pejorative condition number

//%

//%

//%  Additional input parameters

//%  

//%        noi --- (integer)    the number of iteration allowed

//%                               (default: 10)

//%        tol --- (numeric)    the error tolerance

//%                               (default: 1.0d-8)

//%      style --- (integer)    backward error minimization style:

//%                               1 : overall (absolute)

//%                               2 : coefficientwise (relative,default)

//%     prtsty --- (integer)    intermediate results showing style

//%                               0: minimal (default)

//%                               1: plus intermediate backward error and 

//%                                     root corrections

//%                               2: plus intemediate root approximations

//%  Example:

//%

//% » f = polyr2p([ones(1,20),2*ones(1,10),3*ones(1,5)]); % construct the test 

//%                 % polynomial with multiple roots

//% » y = [0.95,2.05,2.95];           % prepare initial iterate

//% » m = [20, 10, 5];                % prepare the multiplicity structure

//% » pejroot(f,y,m)                  % running the program

//% ans =

//%

//%   3.00000000000000   5.00000000000000

//%   2.00000000000000  10.00000000000000

//%   1.00000000000000  20.00000000000000

//%

//%

//%

//

//%HSKOST

//y=[];bkerr=[]; pjcnd=[];

void tmcpejroot(int nargout, int nargin,tmsMatrix *y,tmsMatrix *bkerr,tmsMatrix *pjcnd,tmsMatrix *job
,tmsMatrix *f__input__tmc,tmsMatrix *y0__input__tmc,tmsMatrix *l__input__tmc,tmsMatrix *noi__input__tmc,tmsMatrix *tol__input__tmc,tmsMatrix *style__input__tmc,tmsMatrix *prtsty__input__tmc) {
tmsMatrix **reg=tmcCreateRegFrame(421);
tmsMatrix *f=tmcNewMatrix();
tmsMatrix *y0=tmcNewMatrix();
tmsMatrix *l=tmcNewMatrix();
tmsMatrix *noi=tmcNewMatrix();
tmsMatrix *tol=tmcNewMatrix();
tmsMatrix *style=tmcNewMatrix();
tmsMatrix *prtsty=tmcNewMatrix();
tmsMatrix *m=tmcNewMatrix();
tmsMatrix *n=tmcNewMatrix();
tmsMatrix *jj=tmcNewMatrix();
tmsMatrix *j_=tmcNewMatrix();
tmsMatrix *yy=tmcNewMatrix();
tmsMatrix *h=tmcNewMatrix();
tmsMatrix *delta=tmcNewMatrix();
tmsMatrix *bcker=tmcNewMatrix();
tmsMatrix *w=tmcNewMatrix();
tmsMatrix *k=tmcNewMatrix();
tmsMatrix *Df=tmcNewMatrix();
tmsMatrix *ff=tmcNewMatrix();
tmsMatrix *ll=tmcNewMatrix();
tmsMatrix *mm=tmcNewMatrix();
tmsMatrix *lll=tmcNewMatrix();
tmsMatrix *kk=tmcNewMatrix();
tmsMatrix *id=tmcNewMatrix();
tmsMatrix *g=tmcNewMatrix();
tmsMatrix *c=tmcNewMatrix();
tmsMatrix *b=tmcNewMatrix();
tmsMatrix *d=tmcNewMatrix();
tmsMatrix *A=tmcNewMatrix();
tmsMatrix *s=tmcNewMatrix();

tmcCopyMat(f,f__input__tmc);
tmcCopyMat(y0,y0__input__tmc);
tmcCopyMat(l,l__input__tmc);
tmcCopyMat(noi,noi__input__tmc);
tmcCopyMat(tol,tol__input__tmc);
tmcCopyMat(style,style__input__tmc);
tmcCopyMat(prtsty,prtsty__input__tmc);
TRY
TMC_DBG_PUSH_STACK_VAR("pejroot",41,
f__input__tmc,"f__input__tmc",
y0__input__tmc,"y0__input__tmc",
l__input__tmc,"l__input__tmc",
noi__input__tmc,"noi__input__tmc",
tol__input__tmc,"tol__input__tmc",
style__input__tmc,"style__input__tmc",
prtsty__input__tmc,"prtsty__input__tmc",
y,"y",
bkerr,"bkerr",
pjcnd,"pjcnd",
job,"job",
f,"f",
y0,"y0",
l,"l",
noi,"noi",
tol,"tol",
style,"style",
prtsty,"prtsty",
m,"m",
n,"n",
jj,"jj",
j_,"j_",
yy,"yy",
h,"h",
delta,"delta",
bcker,"bcker",
w,"w",
k,"k",
Df,"Df",
ff,"ff",
ll,"ll",
mm,"mm",
lll,"lll",
kk,"kk",
id,"id",
g,"g",
c,"c",
b,"b",
d,"d",
A,"A",
s,"s");

tmcCreateMatrixEmpty(reg[1]);

tmcAssign(y,reg[1]);
//statement here,line 73

tmcCreateMatrixEmpty(reg[3]);

tmcAssign(bkerr,reg[3]);
//statement here,line 73

tmcCreateMatrixEmpty(reg[5]);

tmcAssign(pjcnd,reg[5]);
//statement here,line 73

// % Lines 74--75:
//

//   if nargin == 3, noi = 10; tol = 1.e-6; style = 2; prtsty = 0; end;

//CALL function
tmcReallocRegister(reg[7]);
tmcnargin(1,0, reg[7]);
tmcScalar(reg[8],3.000000000000000e+000);
tmcEq(reg[9],reg[7],reg[8]);
if(tmcIsFalse(reg[9])) goto label_3; // goto to the end of the clause if the expression is false
tmcScalar(reg[10],1.000000000000000e+001);

tmcAssign(noi,reg[10]);
//statement here,line 75

tmcScalar(reg[12],1.000000000000000e-006);

tmcAssign(tol,reg[12]);
//statement here,line 75

tmcScalar(reg[14],2.000000000000000e+000);

tmcAssign(style,reg[14]);
//statement here,line 75

tmcScalar(reg[16],0.000000000000000e+000);

tmcAssign(prtsty,reg[16]);
//statement here,line 75

goto label_2; //branch to end IF
label_3: ; //end IF clause
label_2: ; //end IF
//statement here,line 75

// % Lines 76--77:
//   

//   m = length(l);    % number of variables


//CALL function
tmcReallocRegister(reg[19]);
tmclength(1,1, reg[19], l);

tmcAssign(m,reg[19]);
//statement here,line 77

// % Lines 78--78:
//   n = sum(l);       % number of equations


//CALL function
tmcReallocRegister(reg[22]);
tmcsum(1,1, reg[22], l);

tmcAssign(n,reg[22]);
//statement here,line 78

// % Lines 79--81:
//   

//   if abs(f(1)) ~= 0     % make the polynomial monic

//       f = f / f(1);


tmcScalar(reg[25],1.000000000000000e+000);
tmcGetByIndex(reg[26],f,1,reg[25]);
//CALL function
tmcReallocRegister(reg[27]);
tmcabs(1,1, reg[27], reg[26]);
tmcScalar(reg[28],0.000000000000000e+000);
tmcNe(reg[29],reg[27],reg[28]);
if(tmcIsFalse(reg[29])) goto label_5; // goto to the end of the clause if the expression is false


tmcScalar(reg[32],1.000000000000000e+000);
tmcGetByIndex(reg[33],f,1,reg[32]);
tmcDiv(reg[34],f,reg[33]);

tmcAssign(f,reg[34]);
//statement here,line 81

// % Lines 82--82:
//   else, jj = find(f);  j_ = min(jj); f = f(j_:length(f));

goto label_4; //branch to end IF
label_5: ; //end IF clause

//CALL function
tmcReallocRegister(reg[37]);
tmcReallocRegister(reg[38]);
tmcReallocRegister(reg[39]);
tmcfind(1,1, reg[37], reg[38], reg[39], f,NULL,NULL);

tmcAssign(jj,reg[37]);
//statement here,line 82


//CALL function
tmcReallocRegister(reg[42]);
tmcReallocRegister(reg[43]);
tmcmin(1,1, reg[42], reg[43], jj,NULL,NULL);

tmcAssign(j_,reg[42]);
//statement here,line 82




//CALL function
tmcReallocRegister(reg[48]);
tmclength(1,1, reg[48], f);
tmcCreateColonBaseLimit(reg[49],j_,reg[48]);
tmcGetByIndex(reg[50],f,1,reg[49]);

tmcAssign(f,reg[50]);
//statement here,line 82

// % Lines 83--83:
//   end;

label_6: ; //end IF clause
label_4: ; //end IF
//statement here,line 83

// % Lines 84--86:
//   

//   if length(f) ~= n+1   % exit if the input is wrong

//       fprintf('In put error');  return;


//CALL function
tmcReallocRegister(reg[53]);
tmclength(1,1, reg[53], f);

tmcScalar(reg[55],1.000000000000000e+000);
tmcAdd(reg[56],n,reg[55]);
tmcNe(reg[57],reg[53],reg[56]);
if(tmcIsFalse(reg[57])) goto label_8; // goto to the end of the clause if the expression is false
tmcCreateString(reg[58],"In put error");
//CALL function
tmcfprintf(0,1, reg[58]);
//statement here,line 86

goto label_1; //branch to FUNCTION exit
//statement here,line 86

// % Lines 87--87:
//   end;

goto label_7; //branch to end IF
label_8: ; //end IF clause
label_7: ; //end IF
//statement here,line 87

// % Lines 88--91:
//       

//   % sort initial values to enhance accuracy

//   % it is interesting, sorting really improves accuracy

//   [yy,jj] = sort(1./abs(y0));   y0 = y0(jj); l = l(jj);

tmcScalar(reg[59],1.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[61]);
tmcabs(1,1, reg[61], y0);
tmcDivScalar(reg[62],reg[59],reg[61]);
//CALL function
tmcReallocRegister(reg[63]);
tmcReallocRegister(reg[64]);
tmcsort(2,1, reg[63], reg[64], reg[62],NULL);

tmcAssign(yy,reg[63]);

tmcAssign(jj,reg[64]);
//statement here,line 91



tmcGetByIndex(reg[69],y0,1,jj);

tmcAssign(y0,reg[69]);
//statement here,line 91



tmcGetByIndex(reg[73],l,1,jj);

tmcAssign(l,reg[73]);
//statement here,line 91

// % Lines 92--93:
//

//   job = 0;               % initialze job

tmcScalar(reg[75],0.000000000000000e+000);

tmcAssign(job,reg[75]);
//statement here,line 93

// % Lines 94--94:
//   y = conj(y0');         % pass the initial iterate


tmcTranspose(reg[78],y0);
//CALL function
tmcReallocRegister(reg[79]);
tmcconj(1,1, reg[79], reg[78]);

tmcAssign(y,reg[79]);
//statement here,line 94

// % Lines 95--95:
//   h = conj(f(2:n+1)');   % make the RHS


tmcScalar(reg[82],2.000000000000000e+000);

tmcScalar(reg[84],1.000000000000000e+000);
tmcAdd(reg[85],n,reg[84]);
tmcCreateColonBaseLimit(reg[86],reg[82],reg[85]);
tmcGetByIndex(reg[87],f,1,reg[86]);
tmcTranspose(reg[88],reg[87]);
//CALL function
tmcReallocRegister(reg[89]);
tmcconj(1,1, reg[89], reg[88]);

tmcAssign(h,reg[89]);
//statement here,line 95

// % Lines 96--96:
//   delta = zeros(1,noi);  % space for sizes of the correction

tmcScalar(reg[91],1.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[93]);
tmczeros(1,2, reg[93], reg[91], noi);

tmcAssign(delta,reg[93]);
//statement here,line 96

// % Lines 97--97:
//   bcker = zeros(1,noi);  % space for backward errors

tmcScalar(reg[95],1.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[97]);
tmczeros(1,2, reg[97], reg[95], noi);

tmcAssign(bcker,reg[97]);
//statement here,line 97

// % Lines 98--99:
//

//   w = ones(n,1);         % set weight


tmcScalar(reg[100],1.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[101]);
tmcones(1,2, reg[101], n, reg[100]);

tmcAssign(w,reg[101]);
//statement here,line 99

// % Lines 100--103:
//   if style == 2

//      for j_ = 1:n

//         if abs(f(j_+1)) >= 1.0 

//            w(j_) = abs(1.0/f(j_+1));


tmcScalar(reg[104],2.000000000000000e+000);
tmcEq(reg[105],style,reg[104]);
if(tmcIsFalse(reg[105])) goto label_10; // goto to the end of the clause if the expression is false
tmcScalar(reg[106],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[108],reg[106],n);
tmcForIterInit(reg[109],reg[108],j_);
label_13: ; //FOR begin
if(tmcForIterNext(reg[109],reg[108])) goto label_12; // exit for


tmcScalar(reg[112],1.000000000000000e+000);
tmcAdd(reg[113],j_,reg[112]);
tmcGetByIndex(reg[114],f,1,reg[113]);
//CALL function
tmcReallocRegister(reg[115]);
tmcabs(1,1, reg[115], reg[114]);
tmcScalar(reg[116],1.000000000000000e+000);
tmcGe(reg[117],reg[115],reg[116]);
if(tmcIsFalse(reg[117])) goto label_15; // goto to the end of the clause if the expression is false
tmcScalar(reg[118],1.000000000000000e+000);


tmcScalar(reg[121],1.000000000000000e+000);
tmcAdd(reg[122],j_,reg[121]);
tmcGetByIndex(reg[123],f,1,reg[122]);
tmcDiv(reg[124],reg[118],reg[123]);
//CALL function
tmcReallocRegister(reg[125]);
tmcabs(1,1, reg[125], reg[124]);


tmcGetRefByIndex(pRefHelper,w,1,j_);
tmcAssign(pRefHelper,reg[125]);
//statement here,line 103

// % Lines 104--104:
//         end

goto label_14; //branch to end IF
label_15: ; //end IF clause
label_14: ; //end IF
//statement here,line 104

// % Lines 105--105:
//      end

label_11: ; //FOR end
goto label_13; //branch to FOR begin
label_12: ; //FOR exit
//statement here,line 105

// % Lines 106--106:
//   end;

goto label_9; //branch to end IF
label_10: ; //end IF clause
label_9: ; //end IF
//statement here,line 106

// % Lines 107--109:
//

//   if prtsty == 1 

//      disp('  ');  disp(' step   bcker         delta')


tmcScalar(reg[129],1.000000000000000e+000);
tmcEq(reg[130],prtsty,reg[129]);
if(tmcIsFalse(reg[130])) goto label_17; // goto to the end of the clause if the expression is false
tmcCreateString(reg[131],"  ");
//CALL function
tmcReallocRegister(reg[132]);
tmcdisp(0,1, reg[132], reg[131]);
//statement here,line 109

tmcCreateString(reg[133]," step   bcker         delta");
//CALL function
tmcReallocRegister(reg[134]);
tmcdisp(0,1, reg[134], reg[133]);
//statement here,line 109

// % Lines 110--110:
//   end

goto label_16; //branch to end IF
label_17: ; //end IF clause
label_16: ; //end IF
//statement here,line 110

// % Lines 111--115:
//

//   for k = 1:noi

//

//      % evaluate the coefficient operator and its Jacobian

//      Df = zeros(n,m);       % open the space for A

tmcScalar(reg[135],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[137],reg[135],noi);
tmcForIterInit(reg[138],reg[137],k);
label_20: ; //FOR begin
if(tmcForIterNext(reg[138],reg[137])) goto label_19; // exit for


//CALL function
tmcReallocRegister(reg[141]);
tmczeros(1,2, reg[141], n, m);

tmcAssign(Df,reg[141]);
//statement here,line 115

// % Lines 116--117:
//      

//      ff = [1];  ll = l - ones(1,m);    % form the base polynomial

tmcScalar(reg[143],1.000000000000000e+000);
tmcCollectColumns(reg[144],1,reg[143]);
tmcCollectRows(reg[145],1,reg[144]);

tmcAssign(ff,reg[145]);
//statement here,line 117


tmcScalar(reg[148],1.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[150]);
tmcones(1,2, reg[150], reg[148], m);
tmcSub(reg[151],l,reg[150]);

tmcAssign(ll,reg[151]);
//statement here,line 117

// % Lines 118--118:
//      mm = max(ll); lll = ll;


//CALL function
tmcReallocRegister(reg[154]);
tmcReallocRegister(reg[155]);
tmcmax(1,1, reg[154], reg[155], ll,NULL,NULL);

tmcAssign(mm,reg[154]);
//statement here,line 118



tmcAssign(lll,ll);
//statement here,line 118

// % Lines 119--120:
//      for kk = 1:mm

//          id = find(lll>0);

tmcScalar(reg[159],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[161],reg[159],mm);
tmcForIterInit(reg[162],reg[161],kk);
label_23: ; //FOR begin
if(tmcForIterNext(reg[162],reg[161])) goto label_22; // exit for

tmcScalar(reg[164],0.000000000000000e+000);
tmcGt(reg[165],lll,reg[164]);
//CALL function
tmcReallocRegister(reg[166]);
tmcReallocRegister(reg[167]);
tmcReallocRegister(reg[168]);
tmcfind(1,1, reg[166], reg[167], reg[168], reg[165],NULL,NULL);

tmcAssign(id,reg[166]);
//statement here,line 120

// % Lines 121--121:
//          ff = conv(ff,polyr2p(y(id)));




tmcGetByIndex(reg[173],y,1,id);
//CALL function
tmcReallocRegister(reg[174]);
tmcpolyr2p(1,1, reg[174], reg[173]);
//CALL function
tmcReallocRegister(reg[175]);
tmcconv(1,2, reg[175], ff, reg[174]);

tmcAssign(ff,reg[175]);
//statement here,line 121

// % Lines 122--122:
//          lll = lll - 1;


tmcScalar(reg[178],1.000000000000000e+000);
tmcSub(reg[179],lll,reg[178]);

tmcAssign(lll,reg[179]);
//statement here,line 122

// % Lines 123--123:
//      end;

label_21: ; //FOR end
goto label_23; //branch to FOR begin
label_22: ; //FOR exit
//statement here,line 123

// % Lines 124--127:
//       

//      for j_ = 1:m               % remaining polynomial multiplication

//         if m > 1

//            id = [1:(j_-1),(j_+1):m]; g = polyr2p(y(id));

tmcScalar(reg[181],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[183],reg[181],m);
tmcForIterInit(reg[184],reg[183],j_);
label_26: ; //FOR begin
if(tmcForIterNext(reg[184],reg[183])) goto label_25; // exit for

tmcScalar(reg[186],1.000000000000000e+000);
tmcGt(reg[187],m,reg[186]);
if(tmcIsFalse(reg[187])) goto label_28; // goto to the end of the clause if the expression is false
tmcScalar(reg[188],1.000000000000000e+000);

tmcScalar(reg[190],1.000000000000000e+000);
tmcSub(reg[191],j_,reg[190]);
tmcCreateColonBaseLimit(reg[192],reg[188],reg[191]);

tmcScalar(reg[194],1.000000000000000e+000);
tmcAdd(reg[195],j_,reg[194]);

tmcCreateColonBaseLimit(reg[197],reg[195],m);
tmcCollectColumns(reg[198],2,reg[192],reg[197]);
tmcCollectRows(reg[199],1,reg[198]);

tmcAssign(id,reg[199]);
//statement here,line 127



tmcGetByIndex(reg[203],y,1,id);
//CALL function
tmcReallocRegister(reg[204]);
tmcpolyr2p(1,1, reg[204], reg[203]);

tmcAssign(g,reg[204]);
//statement here,line 127

// % Lines 128--129:
//         else

//            g = [1];

goto label_27; //branch to end IF
label_28: ; //end IF clause
tmcScalar(reg[206],1.000000000000000e+000);
tmcCollectColumns(reg[207],1,reg[206]);
tmcCollectRows(reg[208],1,reg[207]);

tmcAssign(g,reg[208]);
//statement here,line 129

// % Lines 130--130:
//         end;

label_29: ; //end IF clause
label_27: ; //end IF
//statement here,line 130

// % Lines 131--131:
//         g = conv(-l(j_)*g,ff);  Df(:,j_) = conj(g');



tmcGetByIndex(reg[212],l,1,j_);
tmcNeg(reg[213],reg[212]);

tmcMul(reg[215],reg[213],g);

//CALL function
tmcReallocRegister(reg[217]);
tmcconv(1,2, reg[217], reg[215], ff);

tmcAssign(g,reg[217]);
//statement here,line 131


tmcTranspose(reg[220],g);
//CALL function
tmcReallocRegister(reg[221]);
tmcconj(1,1, reg[221], reg[220]);

tmcCreateMagicColon(reg[223]);

tmcGetRefByIndex(pRefHelper,Df,2,reg[223],j_);
tmcAssign(pRefHelper,reg[221]);
//statement here,line 131

// % Lines 132--132:
//      end

label_24: ; //FOR end
goto label_26; //branch to FOR begin
label_25: ; //FOR exit
//statement here,line 132

// % Lines 133--133:
//      g = conv(-g/l(m), [1,-y(m)]);   % evalulate the coef. operator


tmcNeg(reg[226],g);


tmcGetByIndex(reg[229],l,1,m);
tmcDiv(reg[230],reg[226],reg[229]);
tmcScalar(reg[231],1.000000000000000e+000);


tmcGetByIndex(reg[234],y,1,m);
tmcNeg(reg[235],reg[234]);
tmcCollectColumns(reg[236],2,reg[231],reg[235]);
tmcCollectRows(reg[237],1,reg[236]);
//CALL function
tmcReallocRegister(reg[238]);
tmcconv(1,2, reg[238], reg[230], reg[237]);

tmcAssign(g,reg[238]);
//statement here,line 133

// % Lines 134--134:
//      c = conj(g(2:n+1)');


tmcScalar(reg[241],2.000000000000000e+000);

tmcScalar(reg[243],1.000000000000000e+000);
tmcAdd(reg[244],n,reg[243]);
tmcCreateColonBaseLimit(reg[245],reg[241],reg[244]);
tmcGetByIndex(reg[246],g,1,reg[245]);
tmcTranspose(reg[247],reg[246]);
//CALL function
tmcReallocRegister(reg[248]);
tmcconj(1,1, reg[248], reg[247]);

tmcAssign(c,reg[248]);
//statement here,line 134

// % Lines 135--137:
//      

//      

//      b = c - h;   % RHS of the polyn. system



tmcSub(reg[252],c,h);

tmcAssign(b,reg[252]);
//statement here,line 137

// % Lines 138--140:
//    

//      if style == 2   % scale

//         b = b.*w; for j_ = 1:n,  Df(j_,:) = Df(j_,:)*w(j_); end


tmcScalar(reg[255],2.000000000000000e+000);
tmcEq(reg[256],style,reg[255]);
if(tmcIsFalse(reg[256])) goto label_31; // goto to the end of the clause if the expression is false


tmcMulScalar(reg[259],b,w);

tmcAssign(b,reg[259]);
//statement here,line 140

tmcScalar(reg[261],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[263],reg[261],n);
tmcForIterInit(reg[264],reg[263],j_);
label_34: ; //FOR begin
if(tmcForIterNext(reg[264],reg[263])) goto label_33; // exit for


tmcCreateMagicColon(reg[267]);
tmcGetByIndex(reg[268],Df,2,j_,reg[267]);


tmcGetByIndex(reg[271],w,1,j_);
tmcMul(reg[272],reg[268],reg[271]);


tmcCreateMagicColon(reg[275]);
tmcGetRefByIndex(pRefHelper,Df,2,j_,reg[275]);
tmcAssign(pRefHelper,reg[272]);
//statement here,line 140

label_32: ; //FOR end
goto label_34; //branch to FOR begin
label_33: ; //FOR exit
//statement here,line 140

// % Lines 141--141:
//      end

goto label_30; //branch to end IF
label_31: ; //end IF clause
label_30: ; //end IF
//statement here,line 141

// % Lines 142--143:
//

//      d = Df\b;               % least squares 



tmcLeftDiv(reg[278],Df,b);

tmcAssign(d,reg[278]);
//statement here,line 143

// % Lines 144--144:
//      delta(k) = norm(d,2);   bcker(k) = norm(b,inf);


tmcScalar(reg[281],2.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[282]);
tmcnorm(1,2, reg[282], d, reg[281]);


tmcGetRefByIndex(pRefHelper,delta,1,k);
tmcAssign(pRefHelper,reg[282]);
//statement here,line 144


//CALL function
tmcReallocRegister(reg[286]);
tmcinf(1,0, reg[286]);
//CALL function
tmcReallocRegister(reg[287]);
tmcnorm(1,2, reg[287], b, reg[286]);


tmcGetRefByIndex(pRefHelper,bcker,1,k);
tmcAssign(pRefHelper,reg[287]);
//statement here,line 144

// % Lines 145--146:
//

//      if delta(k) < tol, job = 1; end     % convergence criterion 1



tmcGetByIndex(reg[292],delta,1,k);

tmcLt(reg[294],reg[292],tol);
if(tmcIsFalse(reg[294])) goto label_36; // goto to the end of the clause if the expression is false
tmcScalar(reg[295],1.000000000000000e+000);

tmcAssign(job,reg[295]);
//statement here,line 146

goto label_35; //branch to end IF
label_36: ; //end IF clause
label_35: ; //end IF
//statement here,line 146

// % Lines 147--149:
//      if k > 1 

//         if delta(k) > delta(k-1) & bcker(k) > bcker(k-1)

//            if job == 1, bkerr = bcker(k-1);   break; end;


tmcScalar(reg[298],1.000000000000000e+000);
tmcGt(reg[299],k,reg[298]);
if(tmcIsFalse(reg[299])) goto label_38; // goto to the end of the clause if the expression is false


tmcGetByIndex(reg[302],delta,1,k);


tmcScalar(reg[305],1.000000000000000e+000);
tmcSub(reg[306],k,reg[305]);
tmcGetByIndex(reg[307],delta,1,reg[306]);
tmcGt(reg[308],reg[302],reg[307]);


tmcGetByIndex(reg[311],bcker,1,k);


tmcScalar(reg[314],1.000000000000000e+000);
tmcSub(reg[315],k,reg[314]);
tmcGetByIndex(reg[316],bcker,1,reg[315]);
tmcGt(reg[317],reg[311],reg[316]);
tmcAndScalar(reg[318],reg[308],reg[317]);
if(tmcIsFalse(reg[318])) goto label_40; // goto to the end of the clause if the expression is false

tmcScalar(reg[320],1.000000000000000e+000);
tmcEq(reg[321],job,reg[320]);
if(tmcIsFalse(reg[321])) goto label_42; // goto to the end of the clause if the expression is false


tmcScalar(reg[324],1.000000000000000e+000);
tmcSub(reg[325],k,reg[324]);
tmcGetByIndex(reg[326],bcker,1,reg[325]);

tmcAssign(bkerr,reg[326]);
//statement here,line 149

goto label_19; //break to WHILE exit
//statement here,line 149

goto label_41; //branch to end IF
label_42: ; //end IF clause
label_41: ; //end IF
//statement here,line 149

// % Lines 150--152:
//         elseif delta(k) < delta(k-1)                 % criterion 2

//            if delta(k)^2/(delta(k-1)-delta(k)) < tol, 

//                job = 1; 

goto label_39; //branch to end IF
label_40: ; //end IF clause


tmcGetByIndex(reg[330],delta,1,k);


tmcScalar(reg[333],1.000000000000000e+000);
tmcSub(reg[334],k,reg[333]);
tmcGetByIndex(reg[335],delta,1,reg[334]);
tmcLt(reg[336],reg[330],reg[335]);
if(tmcIsFalse(reg[336])) goto label_43; // goto to the end of the clause if the expression is false


tmcGetByIndex(reg[339],delta,1,k);
tmcScalar(reg[340],2.000000000000000e+000);
tmcPower(reg[341],reg[339],reg[340]);


tmcScalar(reg[344],1.000000000000000e+000);
tmcSub(reg[345],k,reg[344]);
tmcGetByIndex(reg[346],delta,1,reg[345]);


tmcGetByIndex(reg[349],delta,1,k);
tmcSub(reg[350],reg[346],reg[349]);
tmcDiv(reg[351],reg[341],reg[350]);

tmcLt(reg[353],reg[351],tol);
if(tmcIsFalse(reg[353])) goto label_45; // goto to the end of the clause if the expression is false
tmcScalar(reg[354],1.000000000000000e+000);

tmcAssign(job,reg[354]);
//statement here,line 152

// % Lines 153--153:
//            end

goto label_44; //branch to end IF
label_45: ; //end IF clause
label_44: ; //end IF
//statement here,line 153

// % Lines 154--154:
//         end

goto label_39; //branch to end IF
label_43: ; //end IF clause
label_39: ; //end IF
//statement here,line 154

// % Lines 155--155:
//      end

goto label_37; //branch to end IF
label_38: ; //end IF clause
label_37: ; //end IF
//statement here,line 155

// % Lines 156--157:
//      

//      y = y - d;    % correct the roots



tmcSub(reg[358],y,d);

tmcAssign(y,reg[358]);
//statement here,line 157

// % Lines 158--161:
//

//      if prtsty == 1       % intermediate show style 1

//         disp(sprintf(' %2.0f    %10.2e    %10.2e', ...

//                   k, bcker(k),delta(k)))


tmcScalar(reg[361],1.000000000000000e+000);
tmcEq(reg[362],prtsty,reg[361]);
if(tmcIsFalse(reg[362])) goto label_47; // goto to the end of the clause if the expression is false
tmcCreateString(reg[363]," %2.0f    %10.2e    %10.2e");



tmcGetByIndex(reg[367],bcker,1,k);


tmcGetByIndex(reg[370],delta,1,k);
//CALL function
tmcReallocRegister(reg[371]);
tmcsprintf(1,4, reg[371], reg[363], k, reg[367], reg[370]);
//CALL function
tmcReallocRegister(reg[372]);
tmcdisp(0,1, reg[372], reg[371]);
//statement here,line 161

goto label_46; //branch to end IF
label_47: ; //end IF clause

tmcScalar(reg[374],2.000000000000000e+000);
tmcEq(reg[375],prtsty,reg[374]);
if(tmcIsFalse(reg[375])) goto label_48; // goto to the end of the clause if the expression is false



tmcGetByIndex(reg[379],bcker,1,k);


tmcGetByIndex(reg[382],delta,1,k);
tmcCollectColumns(reg[383],3,k,reg[379],reg[382]);
tmcCollectRows(reg[384],1,reg[383]);
//statement here,line -1

// % Lines 162--165:
//      elseif prtsty == 2   % intermediate show style 2

//         [k, bcker(k),delta(k)]

//         y

//      end;


//statement here,line 165

goto label_46; //branch to end IF
label_48: ; //end IF clause
label_46: ; //end IF
//statement here,line 165

// % Lines 166--167:
//  

//      bkerr = bcker(k); A = Df;



tmcGetByIndex(reg[388],bcker,1,k);

tmcAssign(bkerr,reg[388]);
//statement here,line 167



tmcAssign(A,Df);
//statement here,line 167

// % Lines 168--168:
//   end

label_18: ; //FOR end
goto label_20; //branch to FOR begin
label_19: ; //FOR exit
//statement here,line 168

// % Lines 169--171:
//

//   if job == 1

//      s = svd(A); pjcnd = 1/s(m);               % get pej. cond. number


tmcScalar(reg[393],1.000000000000000e+000);
tmcEq(reg[394],job,reg[393]);
if(tmcIsFalse(reg[394])) goto label_50; // goto to the end of the clause if the expression is false

//CALL function
tmcReallocRegister(reg[396]);
tmcReallocRegister(reg[397]);
tmcReallocRegister(reg[398]);
tmcsvd(1,1, reg[396], reg[397], reg[398], A,NULL);

tmcAssign(s,reg[396]);
//statement here,line 171

tmcScalar(reg[400],1.000000000000000e+000);


tmcGetByIndex(reg[403],s,1,m);
tmcDiv(reg[404],reg[400],reg[403]);

tmcAssign(pjcnd,reg[404]);
//statement here,line 171

// % Lines 172--172:
//      [ll,jj] = sort(l);  y = [y(jj),l(jj)'];   % sort by multiplicities


//CALL function
tmcReallocRegister(reg[407]);
tmcReallocRegister(reg[408]);
tmcsort(2,1, reg[407], reg[408], l,NULL);

tmcAssign(ll,reg[407]);

tmcAssign(jj,reg[408]);
//statement here,line 172



tmcGetByIndex(reg[413],y,1,jj);


tmcGetByIndex(reg[416],l,1,jj);
tmcTranspose(reg[417],reg[416]);
tmcCollectColumns(reg[418],2,reg[413],reg[417]);
tmcCollectRows(reg[419],1,reg[418]);

tmcAssign(y,reg[419]);
//statement here,line 172

// % Lines 173--205:
//      %

//      % show off results

//      %

//      %fprintf('\n');

//      %fprintf('    !!!THE COMPUTATION IS SUCCESSFUL!!!\n');

//      %fprintf('\n');

//      %fprintf('THE PEJORATIVE CONDITION NUMBER:     \t\t\t\t  %g \n',pjcnd);

//      %fprintf('THE BACKWARD ERROR:                    %6.2e \n',bkerr);

//      %fprintf('THE ESTIMATED FORWARD ROOT ERROR:      %6.2e \n',...

//      %    2*bkerr*pjcnd);

//      %fprintf('\n');

//      %if norm(imag(y(:,1))) == 0 

//      %   fprintf('        computed roots         multiplicities\n');

//      %   fprintf('\n');

//      %   fprintf('%25.15f \t \t \t %3g \n', y');

//      %else

//      %   fprintf('        computed roots ')

//      %   fprintf('   \t\t\t\t\t\t     multiplicities\n');

//      %   fprintf('\n');

//      %   fprintf('%22.15f + %22.15f i \t \t %3g \n', ...

//      %             [real(y(:,1)),imag(y(:,1)),y(:,2)]');

//      %end;

//   %else

//       %fprintf('\n');

//       %fprintf('The computation in pejroot is unsuccessful, you can try to\n');

//       %fprintf('   1. use better initial iterate, and/or \n');

//       %fprintf('   2. use a better multiplicity strucuture, and/or \n');

//       %fprintf('   3. allow the iteration to run more steps ');

//       %fprintf(' (default: 10 steps)\n');

//       %fprintf('\n');

//       %fprintf('The method may fails when the polynomial is pejoratively\n');

//       %fprintf('ill-conditioned.\n');

//   end;

goto label_49; //branch to end IF
label_50: ; //end IF clause
label_49: ; //end IF
//statement here,line 205

// % Lines 206--206:
label_1: ; //end Function
FINALLY
tmcFreeLocalVar(s);
tmcFreeLocalVar(A);
tmcFreeLocalVar(d);
tmcFreeLocalVar(b);
tmcFreeLocalVar(c);
tmcFreeLocalVar(g);
tmcFreeLocalVar(id);
tmcFreeLocalVar(kk);
tmcFreeLocalVar(lll);
tmcFreeLocalVar(mm);
tmcFreeLocalVar(ll);
tmcFreeLocalVar(ff);
tmcFreeLocalVar(Df);
tmcFreeLocalVar(k);
tmcFreeLocalVar(w);
tmcFreeLocalVar(bcker);
tmcFreeLocalVar(delta);
tmcFreeLocalVar(h);
tmcFreeLocalVar(yy);
tmcFreeLocalVar(j_);
tmcFreeLocalVar(jj);
tmcFreeLocalVar(n);
tmcFreeLocalVar(m);
tmcFreeLocalVar(prtsty);
tmcFreeLocalVar(style);
tmcFreeLocalVar(tol);
tmcFreeLocalVar(noi);
tmcFreeLocalVar(l);
tmcFreeLocalVar(y0);
tmcFreeLocalVar(f);
tmcFreeRegFrame(reg);

TMC_DBG_POP_STACK_VAR(41);

ENDFINALLY
}

//FUNCTION DEFINITION ENDED
//statement here,line 206

// % Lines 207--207:
