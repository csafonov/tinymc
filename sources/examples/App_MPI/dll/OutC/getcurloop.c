//File: getcurloop.c 
//Generated by TMC Converter(C)2009-2016
#include "tmc.h"
#include "stdtmc.h"

#include "TestO.globals.h"

// User provided C-code header (must be included in include path):
#include "External_func.h"

// % Lines 1--16:
//function [PropGain,IntGain,FreqLen,FreqHz,OL_Mag,OL_Ph,CL_Mag,CL_Ph,RespLen,RespTime,Resp]=getcurloop(R,L,Ts,Ovs)

//% Example: calculate open and closed loop for RL curcuit current control

//% Input: R [Ohm], L [Hn] - resistance and inductance

//%        Ts [sec] - sampling time of controller

//%        Ovs [1..1.5] - desired maximal overshoot

//% Output: 

//% PropGain,IntGain : gains of PI controller

//% FreqLen: number of frequencies in result

//% FreqHz,OL_Mag,OL_Ph,CL_Mag,CL_Ph: vectors of

//% frequencies[Hz],Magnitude[dB],Phase[deg] of open-loop and closed-loop

//% RespLen: number of points of responce

//% RespTime [sec],Resp - vectors of time and value of the close-loop step

//% response

//% Author: shmuel safonov , (C) 2017

//% The code is a part of TMC Compiler examples

//PropGain=[];IntGain=[];

void tmcgetcurloop(int nargout, int nargin,tmsMatrix *PropGain,tmsMatrix *IntGain,tmsMatrix *FreqLen,tmsMatrix *FreqHz,tmsMatrix *OL_Mag,tmsMatrix *OL_Ph,tmsMatrix *CL_Mag,tmsMatrix *CL_Ph,tmsMatrix *RespLen,tmsMatrix *RespTime,tmsMatrix *Resp
,tmsMatrix *R__input__tmc,tmsMatrix *L__input__tmc,tmsMatrix *Ts__input__tmc,tmsMatrix *Ovs__input__tmc) {
tmsMatrix **reg=tmcCreateRegFrame(792);
tmsMatrix *R=tmcNewMatrix();
tmsMatrix *L=tmcNewMatrix();
tmsMatrix *Ts=tmcNewMatrix();
tmsMatrix *Ovs=tmcNewMatrix();
tmsMatrix *COMM=tmcNewMatrix();
tmsMatrix *numproc=tmcNewMatrix();
tmsMatrix *my_rank=tmcNewMatrix();
tmsMatrix *str=tmcNewMatrix();
tmsMatrix *D=tmcNewMatrix();
tmsMatrix *PhaseM=tmcNewMatrix();
tmsMatrix *GainM=tmcNewMatrix();
tmsMatrix *MaxW=tmcNewMatrix();
tmsMatrix *L1=tmcNewMatrix();
tmsMatrix *L2=tmcNewMatrix();
tmsMatrix *w1=tmcNewMatrix();
tmsMatrix *s1=tmcNewMatrix();
tmsMatrix *B1=tmcNewMatrix();
tmsMatrix *LL1=tmcNewMatrix();
tmsMatrix *Ki=tmcNewMatrix();
tmsMatrix *Kp=tmcNewMatrix();
tmsMatrix *II=tmcNewMatrix();
tmsMatrix *w=tmcNewMatrix();
tmsMatrix *s=tmcNewMatrix();
tmsMatrix *z=tmcNewMatrix();
tmsMatrix *Ph2=tmcNewMatrix();
tmsMatrix *Sol_opt=tmcNewMatrix();
tmsMatrix *Ovs_Opt=tmcNewMatrix();
tmsMatrix *Lopen_opt=tmcNewMatrix();
tmsMatrix *Ovs_array=tmcNewMatrix();
tmsMatrix *Ovs_array_len=tmcNewMatrix();
tmsMatrix *LL=tmcNewMatrix();
tmsMatrix *Tasks=tmcNewMatrix();
tmsMatrix *PortionPerProcess=tmcNewMatrix();
tmsMatrix *kk=tmcNewMatrix();
tmsMatrix *RANKS=tmcNewMatrix();
tmsMatrix *nActiveProc=tmcNewMatrix();
tmsMatrix *cnt=tmcNewMatrix();
tmsMatrix *INFO=tmcNewMatrix();
tmsMatrix *MyTask=tmcNewMatrix();
tmsMatrix *yy_opt=tmcNewMatrix();
tmsMatrix *NomC=tmcNewMatrix();
tmsMatrix *Sol=tmcNewMatrix();
tmsMatrix *Lopen=tmcNewMatrix();
tmsMatrix *II1=tmcNewMatrix();
tmsMatrix *Ph1=tmcNewMatrix();
tmsMatrix *CL=tmcNewMatrix();
tmsMatrix *YY=tmcNewMatrix();
tmsMatrix *n=tmcNewMatrix();
tmsMatrix *kp0=tmcNewMatrix();
tmsMatrix *ki0=tmcNewMatrix();
tmsMatrix *Lopen0=tmcNewMatrix();
tmsMatrix *rden=tmcNewMatrix();
tmsMatrix *rdend=tmcNewMatrix();
tmsMatrix *sysP1d=tmcNewMatrix();
tmsMatrix *sysP2d=tmcNewMatrix();
tmsMatrix *sysPd=tmcNewMatrix();
tmsMatrix *sysPCLd=tmcNewMatrix();
tmsMatrix *num=tmcNewMatrix();
tmsMatrix *den=tmcNewMatrix();
tmsMatrix *yy=tmcNewMatrix();
tmsMatrix *ActOvs=tmcNewMatrix();
tmsMatrix *CL_Opt=tmcNewMatrix();
tmsMatrix *g_Sol_opt=tmcNewMatrix();
tmsMatrix *g_Ovs_Opt=tmcNewMatrix();
tmsMatrix *g_Lopen_opt=tmcNewMatrix();
tmsMatrix *g_CL_Opt=tmcNewMatrix();
tmsMatrix *g_yy_opt=tmcNewMatrix();

tmcCopyMat(R,R__input__tmc);
tmcCopyMat(L,L__input__tmc);
tmcCopyMat(Ts,Ts__input__tmc);
tmcCopyMat(Ovs,Ovs__input__tmc);
TRY
TMC_DBG_PUSH_STACK_VAR("getcurloop",82,
R__input__tmc,"R__input__tmc",
L__input__tmc,"L__input__tmc",
Ts__input__tmc,"Ts__input__tmc",
Ovs__input__tmc,"Ovs__input__tmc",
PropGain,"PropGain",
IntGain,"IntGain",
FreqLen,"FreqLen",
FreqHz,"FreqHz",
OL_Mag,"OL_Mag",
OL_Ph,"OL_Ph",
CL_Mag,"CL_Mag",
CL_Ph,"CL_Ph",
RespLen,"RespLen",
RespTime,"RespTime",
Resp,"Resp",
R,"R",
L,"L",
Ts,"Ts",
Ovs,"Ovs",
COMM,"COMM",
numproc,"numproc",
my_rank,"my_rank",
str,"str",
D,"D",
PhaseM,"PhaseM",
GainM,"GainM",
MaxW,"MaxW",
L1,"L1",
L2,"L2",
w1,"w1",
s1,"s1",
B1,"B1",
LL1,"LL1",
Ki,"Ki",
Kp,"Kp",
II,"II",
w,"w",
s,"s",
z,"z",
Ph2,"Ph2",
Sol_opt,"Sol_opt",
Ovs_Opt,"Ovs_Opt",
Lopen_opt,"Lopen_opt",
Ovs_array,"Ovs_array",
Ovs_array_len,"Ovs_array_len",
LL,"LL",
Tasks,"Tasks",
PortionPerProcess,"PortionPerProcess",
kk,"kk",
RANKS,"RANKS",
nActiveProc,"nActiveProc",
cnt,"cnt",
INFO,"INFO",
MyTask,"MyTask",
yy_opt,"yy_opt",
NomC,"NomC",
Sol,"Sol",
Lopen,"Lopen",
II1,"II1",
Ph1,"Ph1",
CL,"CL",
YY,"YY",
n,"n",
kp0,"kp0",
ki0,"ki0",
Lopen0,"Lopen0",
rden,"rden",
rdend,"rdend",
sysP1d,"sysP1d",
sysP2d,"sysP2d",
sysPd,"sysPd",
sysPCLd,"sysPCLd",
num,"num",
den,"den",
yy,"yy",
ActOvs,"ActOvs",
CL_Opt,"CL_Opt",
g_Sol_opt,"g_Sol_opt",
g_Ovs_Opt,"g_Ovs_Opt",
g_Lopen_opt,"g_Lopen_opt",
g_CL_Opt,"g_CL_Opt",
g_yy_opt,"g_yy_opt");

tmcCreateMatrixEmpty(reg[1]);

tmcAssign(PropGain,reg[1]);
//statement here,line 16

tmcCreateMatrixEmpty(reg[3]);

tmcAssign(IntGain,reg[3]);
//statement here,line 16

// % Lines 17--17:
//FreqLen=0;FreqHz=[];OL_Mag=[];OL_Ph=[];CL_Mag=[];CL_Ph=[];

tmcScalar(reg[5],0.000000000000000e+000);

tmcAssign(FreqLen,reg[5]);
//statement here,line 17

tmcCreateMatrixEmpty(reg[7]);

tmcAssign(FreqHz,reg[7]);
//statement here,line 17

tmcCreateMatrixEmpty(reg[9]);

tmcAssign(OL_Mag,reg[9]);
//statement here,line 17

tmcCreateMatrixEmpty(reg[11]);

tmcAssign(OL_Ph,reg[11]);
//statement here,line 17

tmcCreateMatrixEmpty(reg[13]);

tmcAssign(CL_Mag,reg[13]);
//statement here,line 17

tmcCreateMatrixEmpty(reg[15]);

tmcAssign(CL_Ph,reg[15]);
//statement here,line 17

// % Lines 18--18:
//RespLen=0;RespTime=[];Resp=[];

tmcScalar(reg[17],0.000000000000000e+000);

tmcAssign(RespLen,reg[17]);
//statement here,line 18

tmcCreateMatrixEmpty(reg[19]);

tmcAssign(RespTime,reg[19]);
//statement here,line 18

tmcCreateMatrixEmpty(reg[21]);

tmcAssign(Resp,reg[21]);
//statement here,line 18

// % Lines 19--20:
//if nargin==0

//    R = 0.2;

//CALL function
tmcReallocRegister(reg[23]);
tmcnargin(1,0, reg[23]);
tmcScalar(reg[24],0.000000000000000e+000);
tmcEq(reg[25],reg[23],reg[24]);
if(tmcIsFalse(reg[25])) goto label_3; // goto to the end of the clause if the expression is false
tmcScalar(reg[26],2.000000000000000e-001);

tmcAssign(R,reg[26]);
//statement here,line 20

// % Lines 21--21:
//    L = 0.002;

tmcScalar(reg[28],2.000000000000000e-003);

tmcAssign(L,reg[28]);
//statement here,line 21

// % Lines 22--22:
//    Ts = 50e-6;

tmcScalar(reg[30],5.000000000000000e-005);

tmcAssign(Ts,reg[30]);
//statement here,line 22

// % Lines 23--23:
//    Ovs = 1.15;

tmcScalar(reg[32],1.150000000000000e+000);

tmcAssign(Ovs,reg[32]);
//statement here,line 23

// % Lines 24--24:
//end

goto label_2; //branch to end IF
label_3: ; //end IF clause
label_2: ; //end IF
//statement here,line 24

// % Lines 25--26:
//

//COMM=MPI_Comm_Load;

//CALL function
tmcReallocRegister(reg[34]);
tmcMPI_Comm_Load(1,0, reg[34],NULL);

tmcAssign(COMM,reg[34]);
//statement here,line 26

// % Lines 27--27:
//numproc = MPI_Comm_size(COMM);


//CALL function
tmcReallocRegister(reg[37]);
tmcMPI_Comm_size(1,1, reg[37], COMM);

tmcAssign(numproc,reg[37]);
//statement here,line 27

// % Lines 28--28:
//my_rank = MPI_Comm_rank(COMM);


//CALL function
tmcReallocRegister(reg[40]);
tmcMPI_Comm_rank(1,1, reg[40], COMM);

tmcAssign(my_rank,reg[40]);
//statement here,line 28

// % Lines 29--29:
//str = ['We are running on ',num2str(numproc), ' cores. I am ',num2str(my_rank)];

tmcCreateString(reg[42],"We are running on ");

//CALL function
tmcReallocRegister(reg[44]);
tmcnum2str(1,1, reg[44], numproc,NULL);
tmcCreateString(reg[45]," cores. I am ");

//CALL function
tmcReallocRegister(reg[47]);
tmcnum2str(1,1, reg[47], my_rank,NULL);
tmcCollectColumns(reg[48],4,reg[42],reg[44],reg[45],reg[47]);
tmcCollectRows(reg[49],1,reg[48]);

tmcAssign(str,reg[49]);
//statement here,line 29

// % Lines 30--30:
//disp(str);


//CALL function
tmcReallocRegister(reg[52]);
tmcdisp(0,1, reg[52], str);
//statement here,line 30

// % Lines 31--32:
//

//D  = 0.5*Ts;

tmcScalar(reg[53],5.000000000000000e-001);

tmcMul(reg[55],reg[53],Ts);

tmcAssign(D,reg[55]);
//statement here,line 32

// % Lines 33--33:
//PhaseM=40;GainM=-8;

tmcScalar(reg[57],4.000000000000000e+001);

tmcAssign(PhaseM,reg[57]);
//statement here,line 33

tmcScalar(reg[59],8.000000000000000e+000);
tmcNeg(reg[60],reg[59]);

tmcAssign(GainM,reg[60]);
//statement here,line 33

// % Lines 34--34:
//MaxW = (PhaseM/360)*2*pi / (Ts+D);


tmcScalar(reg[63],3.600000000000000e+002);
tmcDiv(reg[64],PhaseM,reg[63]);
tmcScalar(reg[65],2.000000000000000e+000);
tmcMul(reg[66],reg[64],reg[65]);
//CALL function
tmcReallocRegister(reg[67]);
tmcpi(1,0, reg[67]);
tmcMul(reg[68],reg[66],reg[67]);


tmcAdd(reg[71],Ts,D);
tmcDiv(reg[72],reg[68],reg[71]);

tmcAssign(MaxW,reg[72]);
//statement here,line 34

// % Lines 35--35:
//L1 = -10^(GainM/20);

tmcScalar(reg[74],1.000000000000000e+001);

tmcScalar(reg[76],2.000000000000000e+001);
tmcDiv(reg[77],GainM,reg[76]);
tmcPower(reg[78],reg[74],reg[77]);
tmcNeg(reg[79],reg[78]);

tmcAssign(L1,reg[79]);
//statement here,line 35

// % Lines 36--36:
//L2 = exp(1j*(-pi + (PhaseM/360)*2*pi));

tmcComplexScalar(reg[81],0.000000000000000e+000,1.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[82]);
tmcpi(1,0, reg[82]);
tmcNeg(reg[83],reg[82]);

tmcScalar(reg[85],3.600000000000000e+002);
tmcDiv(reg[86],PhaseM,reg[85]);
tmcScalar(reg[87],2.000000000000000e+000);
tmcMul(reg[88],reg[86],reg[87]);
//CALL function
tmcReallocRegister(reg[89]);
tmcpi(1,0, reg[89]);
tmcMul(reg[90],reg[88],reg[89]);
tmcAdd(reg[91],reg[83],reg[90]);
tmcMul(reg[92],reg[81],reg[91]);
//CALL function
tmcReallocRegister(reg[93]);
tmcexp(1,1, reg[93], reg[92]);

tmcAssign(L2,reg[93]);
//statement here,line 36

// % Lines 37--37:
//w1 = linspace(0.01*MaxW,MaxW*10,2000);

tmcScalar(reg[95],1.000000000000000e-002);

tmcMul(reg[97],reg[95],MaxW);

tmcScalar(reg[99],1.000000000000000e+001);
tmcMul(reg[100],MaxW,reg[99]);
tmcScalar(reg[101],2.000000000000000e+003);
//CALL function
tmcReallocRegister(reg[102]);
tmclinspace(1,3, reg[102], reg[97], reg[100], reg[101]);

tmcAssign(w1,reg[102]);
//statement here,line 37

// % Lines 38--38:
//s1 = j*w1;

//CALL function
tmcReallocRegister(reg[104]);
tmcj(1,0, reg[104]);

tmcMul(reg[106],reg[104],w1);

tmcAssign(s1,reg[106]);
//statement here,line 38

// % Lines 39--39:
//B1=exp(-(D+Ts)*s1);



tmcAdd(reg[110],D,Ts);
tmcNeg(reg[111],reg[110]);

tmcMul(reg[113],reg[111],s1);
//CALL function
tmcReallocRegister(reg[114]);
tmcexp(1,1, reg[114], reg[113]);

tmcAssign(B1,reg[114]);
//statement here,line 39

// % Lines 40--40:
//LL1 = L1./B1.*(s1*R+s1.*s1*L);



tmcDivScalar(reg[118],L1,B1);


tmcMul(reg[121],s1,R);


tmcMulScalar(reg[124],s1,s1);

tmcMul(reg[126],reg[124],L);
tmcAdd(reg[127],reg[121],reg[126]);
tmcMulScalar(reg[128],reg[118],reg[127]);

tmcAssign(LL1,reg[128]);
//statement here,line 40

// % Lines 41--41:
//Ki=(real(LL1));


//CALL function
tmcReallocRegister(reg[131]);
tmcreal(1,1, reg[131], LL1);

tmcAssign(Ki,reg[131]);
//statement here,line 41

// % Lines 42--42:
//Kp=(imag(LL1)./w1);


//CALL function
tmcReallocRegister(reg[134]);
tmcimag(1,1, reg[134], LL1);

tmcDivScalar(reg[136],reg[134],w1);

tmcAssign(Kp,reg[136]);
//statement here,line 42

// % Lines 43--43:
//II=find(Ki>0 & Kp>0 );


tmcScalar(reg[139],0.000000000000000e+000);
tmcGt(reg[140],Ki,reg[139]);

tmcScalar(reg[142],0.000000000000000e+000);
tmcGt(reg[143],Kp,reg[142]);
tmcAndScalar(reg[144],reg[140],reg[143]);
//CALL function
tmcReallocRegister(reg[145]);
tmcReallocRegister(reg[146]);
tmcReallocRegister(reg[147]);
tmcfind(1,1, reg[145], reg[146], reg[147], reg[144],NULL,NULL);

tmcAssign(II,reg[145]);
//statement here,line 43

// % Lines 44--44:
//Ki=Ki(II);



tmcGetByIndex(reg[151],Ki,1,II);

tmcAssign(Ki,reg[151]);
//statement here,line 44

// % Lines 45--45:
//Kp=Kp(II);



tmcGetByIndex(reg[155],Kp,1,II);

tmcAssign(Kp,reg[155]);
//statement here,line 45

// % Lines 46--52:
//

//% figure(100);

//% subplot(2,1,1);

//% plot(w1,Kp,'r' );grid on;legend('kp');

//% subplot(2,1,2);

//% plot( w1,Ki,'b');grid on;legend('ki');

//w = logspace(log10(1) ,log10(0.5./Ts*2*pi),1000);

tmcScalar(reg[157],1.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[158]);
tmclog10(1,1, reg[158], reg[157]);
tmcScalar(reg[159],5.000000000000000e-001);

tmcDivScalar(reg[161],reg[159],Ts);
tmcScalar(reg[162],2.000000000000000e+000);
tmcMul(reg[163],reg[161],reg[162]);
//CALL function
tmcReallocRegister(reg[164]);
tmcpi(1,0, reg[164]);
tmcMul(reg[165],reg[163],reg[164]);
//CALL function
tmcReallocRegister(reg[166]);
tmclog10(1,1, reg[166], reg[165]);
tmcScalar(reg[167],1.000000000000000e+003);
//CALL function
tmcReallocRegister(reg[168]);
tmclogspace(1,3, reg[168], reg[158], reg[166], reg[167]);

tmcAssign(w,reg[168]);
//statement here,line 52

// % Lines 53--53:
//s = 1j*w;

tmcComplexScalar(reg[170],0.000000000000000e+000,1.000000000000000e+000);

tmcMul(reg[172],reg[170],w);

tmcAssign(s,reg[172]);
//statement here,line 53

// % Lines 54--54:
//z = s*Ts;



tmcMul(reg[176],s,Ts);

tmcAssign(z,reg[176]);
//statement here,line 54

// % Lines 55--55:
//Ph2=angle(L2);


//CALL function
tmcReallocRegister(reg[179]);
tmcangle(1,1, reg[179], L2);

tmcAssign(Ph2,reg[179]);
//statement here,line 55

// % Lines 56--57:
//if Ph2>0

//    Ph2=Ph2-2*pi;


tmcScalar(reg[182],0.000000000000000e+000);
tmcGt(reg[183],Ph2,reg[182]);
if(tmcIsFalse(reg[183])) goto label_5; // goto to the end of the clause if the expression is false

tmcScalar(reg[185],2.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[186]);
tmcpi(1,0, reg[186]);
tmcMul(reg[187],reg[185],reg[186]);
tmcSub(reg[188],Ph2,reg[187]);

tmcAssign(Ph2,reg[188]);
//statement here,line 57

// % Lines 58--58:
//end

goto label_4; //branch to end IF
label_5: ; //end IF clause
label_4: ; //end IF
//statement here,line 58

// % Lines 59--60:
//

//Sol_opt=[];Ovs_Opt=[];Lopen_opt=[];

tmcCreateMatrixEmpty(reg[190]);

tmcAssign(Sol_opt,reg[190]);
//statement here,line 60

tmcCreateMatrixEmpty(reg[192]);

tmcAssign(Ovs_Opt,reg[192]);
//statement here,line 60

tmcCreateMatrixEmpty(reg[194]);

tmcAssign(Lopen_opt,reg[194]);
//statement here,line 60

// % Lines 61--63:
//

//if my_rank==0 % master

//    Ovs_array = [0.8:0.05:1.2]*Ovs;


tmcScalar(reg[197],0.000000000000000e+000);
tmcEq(reg[198],my_rank,reg[197]);
if(tmcIsFalse(reg[198])) goto label_7; // goto to the end of the clause if the expression is false
tmcScalar(reg[199],8.000000000000000e-001);
tmcScalar(reg[200],1.200000000000000e+000);
tmcScalar(reg[201],5.000000000000000e-002);
tmcCreateColonBaseIncLimit(reg[202],reg[199],reg[201],reg[200]);
tmcCollectColumns(reg[203],1,reg[202]);
tmcCollectRows(reg[204],1,reg[203]);

tmcMul(reg[206],reg[204],Ovs);

tmcAssign(Ovs_array,reg[206]);
//statement here,line 63

// % Lines 64--64:
//    disp(' distribute the task between the processes');

tmcCreateString(reg[208]," distribute the task between the processes");
//CALL function
tmcReallocRegister(reg[209]);
tmcdisp(0,1, reg[209], reg[208]);
//statement here,line 64

// % Lines 65--65:
//    Ovs_array_len  = length(Ovs_array);


//CALL function
tmcReallocRegister(reg[211]);
tmclength(1,1, reg[211], Ovs_array);

tmcAssign(Ovs_array_len,reg[211]);
//statement here,line 65

// % Lines 66--66:
//    LL=Ovs_array_len;



tmcAssign(LL,Ovs_array_len);
//statement here,line 66

// % Lines 67--67:
//    Tasks = cell(1,numproc);

tmcScalar(reg[215],1.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[217]);
tmccell(1,2, reg[217], reg[215], numproc);

tmcAssign(Tasks,reg[217]);
//statement here,line 67

// % Lines 68--68:
//    PortionPerProcess = ceil(Ovs_array_len / numproc);



tmcDiv(reg[221],Ovs_array_len,numproc);
//CALL function
tmcReallocRegister(reg[222]);
tmcceil(1,1, reg[222], reg[221]);

tmcAssign(PortionPerProcess,reg[222]);
//statement here,line 68

// % Lines 69--70:
//    for kk=1:numproc

//        Tasks{kk} = Ovs_array([1:PortionPerProcess] + (kk-1)*PortionPerProcess);

tmcScalar(reg[224],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[226],reg[224],numproc);
tmcForIterInit(reg[227],reg[226],kk);
label_10: ; //FOR begin
if(tmcForIterNext(reg[227],reg[226])) goto label_9; // exit for

tmcScalar(reg[229],1.000000000000000e+000);

tmcCreateColonBaseLimit(reg[231],reg[229],PortionPerProcess);
tmcCollectColumns(reg[232],1,reg[231]);
tmcCollectRows(reg[233],1,reg[232]);

tmcScalar(reg[235],1.000000000000000e+000);
tmcSub(reg[236],kk,reg[235]);

tmcMul(reg[238],reg[236],PortionPerProcess);
tmcAdd(reg[239],reg[233],reg[238]);
tmcGetByIndex(reg[240],Ovs_array,1,reg[239]);


tmcGetRefByIndexCell(pRefHelper,Tasks,1,kk);
tmcAssign(pRefHelper,reg[240]);
//statement here,line 70

// % Lines 71--71:
//        LL=LL-PortionPerProcess;



tmcSub(reg[245],LL,PortionPerProcess);

tmcAssign(LL,reg[245]);
//statement here,line 71

// % Lines 72--73:
//        if LL==0

//            break;


tmcScalar(reg[248],0.000000000000000e+000);
tmcEq(reg[249],LL,reg[248]);
if(tmcIsFalse(reg[249])) goto label_12; // goto to the end of the clause if the expression is false
goto label_9; //break to WHILE exit
//statement here,line 73

// % Lines 74--74:
//        end

goto label_11; //branch to end IF
label_12: ; //end IF clause
label_11: ; //end IF
//statement here,line 74

// % Lines 75--75:
//    end

label_8: ; //FOR end
goto label_10; //branch to FOR begin
label_9: ; //FOR exit
//statement here,line 75

// % Lines 76--77:
//    if LL>0

//        Tasks{numproc} = [Tasks{numproc}, Ovs_array(end-LL:end) ];


tmcScalar(reg[251],0.000000000000000e+000);
tmcGt(reg[252],LL,reg[251]);
if(tmcIsFalse(reg[252])) goto label_14; // goto to the end of the clause if the expression is false


tmcGetByIndexCell(reg[255],Tasks,1,numproc);

tmcGetEnd(reg[257],Ovs_array,1,1);

tmcSub(reg[259],reg[257],LL);
tmcGetEnd(reg[260],Ovs_array,1,1);
tmcCreateColonBaseLimit(reg[261],reg[259],reg[260]);
tmcGetByIndex(reg[262],Ovs_array,1,reg[261]);
tmcCollectColumns(reg[263],2,reg[255],reg[262]);
tmcCollectRows(reg[264],1,reg[263]);


tmcGetRefByIndexCell(pRefHelper,Tasks,1,numproc);
tmcAssign(pRefHelper,reg[264]);
//statement here,line 77

// % Lines 78--78:
//    end

goto label_13; //branch to end IF
label_14: ; //end IF clause
label_13: ; //end IF
//statement here,line 78

// % Lines 79--80:
//    

//    RANKS  = [0:numproc-1];

tmcScalar(reg[267],0.000000000000000e+000);

tmcScalar(reg[269],1.000000000000000e+000);
tmcSub(reg[270],numproc,reg[269]);
tmcCreateColonBaseLimit(reg[271],reg[267],reg[270]);
tmcCollectColumns(reg[272],1,reg[271]);
tmcCollectRows(reg[273],1,reg[272]);

tmcAssign(RANKS,reg[273]);
//statement here,line 80

// % Lines 81--81:
//    nActiveProc = numproc;



tmcAssign(nActiveProc,numproc);
//statement here,line 81

// % Lines 82--83:
//    for cnt=2:numproc

//        INFO = MPI_Send(Tasks{cnt},RANKS(cnt),0,COMM);

tmcScalar(reg[277],2.000000000000000e+000);

tmcCreateColonBaseLimit(reg[279],reg[277],numproc);
tmcForIterInit(reg[280],reg[279],cnt);
label_17: ; //FOR begin
if(tmcForIterNext(reg[280],reg[279])) goto label_16; // exit for


tmcGetByIndexCell(reg[283],Tasks,1,cnt);


tmcGetByIndex(reg[286],RANKS,1,cnt);
tmcScalar(reg[287],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[289]);
tmcMPI_Send(1,4, reg[289], reg[283], reg[286], reg[287], COMM);

tmcAssign(INFO,reg[289]);
//statement here,line 83

// % Lines 84--85:
//        if isempty(Tasks{cnt})

//            nActiveProc=nActiveProc-1;



tmcGetByIndexCell(reg[293],Tasks,1,cnt);
//CALL function
tmcReallocRegister(reg[294]);
tmcisempty(1,1, reg[294], reg[293]);
if(tmcIsFalse(reg[294])) goto label_19; // goto to the end of the clause if the expression is false

tmcScalar(reg[297],1.000000000000000e+000);
tmcSub(reg[298],nActiveProc,reg[297]);

tmcAssign(nActiveProc,reg[298]);
//statement here,line 85

// % Lines 86--86:
//        end

goto label_18; //branch to end IF
label_19: ; //end IF clause
label_18: ; //end IF
//statement here,line 86

// % Lines 87--87:
//    end

label_15: ; //FOR end
goto label_17; //branch to FOR begin
label_16: ; //FOR exit
//statement here,line 87

// % Lines 88--88:
//    MyTask = Tasks{1};


tmcScalar(reg[301],1.000000000000000e+000);
tmcGetByIndexCell(reg[302],Tasks,1,reg[301]);

tmcAssign(MyTask,reg[302]);
//statement here,line 88

// % Lines 89--90:
//else

//    [MyTask, INFO] = MPI_Recv(0,0,COMM);

goto label_6; //branch to end IF
label_7: ; //end IF clause
tmcScalar(reg[304],0.000000000000000e+000);
tmcScalar(reg[305],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[307]);
tmcReallocRegister(reg[308]);
tmcMPI_Recv(2,3, reg[307], reg[308], reg[304], reg[305], COMM);

tmcAssign(MyTask,reg[307]);

tmcAssign(INFO,reg[308]);
//statement here,line 90

// % Lines 91--91:
//    disp('Received matrix:');

tmcCreateString(reg[311],"Received matrix:");
//CALL function
tmcReallocRegister(reg[312]);
tmcdisp(0,1, reg[312], reg[311]);
//statement here,line 91

// % Lines 92--92:
//    disp(MyTask);


//CALL function
tmcReallocRegister(reg[314]);
tmcdisp(0,1, reg[314], MyTask);
//statement here,line 92

// % Lines 93--94:
//    if isempty(MyTask)

//        return;


//CALL function
tmcReallocRegister(reg[316]);
tmcisempty(1,1, reg[316], MyTask);
if(tmcIsFalse(reg[316])) goto label_22; // goto to the end of the clause if the expression is false
goto label_1; //branch to FUNCTION exit
//statement here,line 94

// % Lines 95--95:
//    end

goto label_21; //branch to end IF
label_22: ; //end IF clause
label_21: ; //end IF
//statement here,line 95

// % Lines 96--96:
//end

label_20: ; //end IF clause
label_6: ; //end IF
//statement here,line 96

// % Lines 97--100:
//

//

//%//for NomC=[0.8:0.05:1.2]*Ovs

//yy_opt=[];

tmcCreateMatrixEmpty(reg[318]);

tmcAssign(yy_opt,reg[318]);
//statement here,line 100

// % Lines 101--103:
//for NomC=MyTask

//    %%    figure(300);%clf;

//    Sol=[];


tmcForIterInit(reg[322],MyTask,NomC);
label_25: ; //FOR begin
if(tmcForIterNext(reg[322],MyTask)) goto label_24; // exit for
tmcCreateMatrixEmpty(reg[323]);

tmcAssign(Sol,reg[323]);
//statement here,line 103

// % Lines 104--105:
//    for kk=1:length(Kp)

//        Lopen = (Kp(kk)+Ki(kk)./s)./(R+s*L) .* exp(-(D+Ts).*s);

tmcScalar(reg[325],1.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[327]);
tmclength(1,1, reg[327], Kp);
tmcCreateColonBaseLimit(reg[328],reg[325],reg[327]);
tmcForIterInit(reg[329],reg[328],kk);
label_28: ; //FOR begin
if(tmcForIterNext(reg[329],reg[328])) goto label_27; // exit for


tmcGetByIndex(reg[332],Kp,1,kk);


tmcGetByIndex(reg[335],Ki,1,kk);

tmcDivScalar(reg[337],reg[335],s);
tmcAdd(reg[338],reg[332],reg[337]);



tmcMul(reg[342],s,L);
tmcAdd(reg[343],R,reg[342]);
tmcDivScalar(reg[344],reg[338],reg[343]);


tmcAdd(reg[347],D,Ts);
tmcNeg(reg[348],reg[347]);

tmcMulScalar(reg[350],reg[348],s);
//CALL function
tmcReallocRegister(reg[351]);
tmcexp(1,1, reg[351], reg[350]);
tmcMulScalar(reg[352],reg[344],reg[351]);

tmcAssign(Lopen,reg[352]);
//statement here,line 105

// % Lines 106--107:
//        %  Lopen = (Kp(kk)+Ts*Ki(kk)./(z-1))./(R+s*L) .* exp(-(D+Ts).*s);

//        II1 = find( abs(Lopen)>1);


//CALL function
tmcReallocRegister(reg[355]);
tmcabs(1,1, reg[355], Lopen);
tmcScalar(reg[356],1.000000000000000e+000);
tmcGt(reg[357],reg[355],reg[356]);
//CALL function
tmcReallocRegister(reg[358]);
tmcReallocRegister(reg[359]);
tmcReallocRegister(reg[360]);
tmcfind(1,1, reg[358], reg[359], reg[360], reg[357],NULL,NULL);

tmcAssign(II1,reg[358]);
//statement here,line 107

// % Lines 108--109:
//        if ~isempty(II1)

//            II1=II1(end);


//CALL function
tmcReallocRegister(reg[363]);
tmcisempty(1,1, reg[363], II1);
tmcNot(reg[364],reg[363]);
if(tmcIsFalse(reg[364])) goto label_30; // goto to the end of the clause if the expression is false

tmcGetEnd(reg[366],II1,1,1);
tmcGetByIndex(reg[367],II1,1,reg[366]);

tmcAssign(II1,reg[367]);
//statement here,line 109

// % Lines 110--110:
//            Ph1 = angle(Lopen(II1));



tmcGetByIndex(reg[371],Lopen,1,II1);
//CALL function
tmcReallocRegister(reg[372]);
tmcangle(1,1, reg[372], reg[371]);

tmcAssign(Ph1,reg[372]);
//statement here,line 110

// % Lines 111--112:
//            if Ph1>0

//                Ph1=Ph1-2*pi;


tmcScalar(reg[375],0.000000000000000e+000);
tmcGt(reg[376],Ph1,reg[375]);
if(tmcIsFalse(reg[376])) goto label_32; // goto to the end of the clause if the expression is false

tmcScalar(reg[378],2.000000000000000e+000);
//CALL function
tmcReallocRegister(reg[379]);
tmcpi(1,0, reg[379]);
tmcMul(reg[380],reg[378],reg[379]);
tmcSub(reg[381],Ph1,reg[380]);

tmcAssign(Ph1,reg[381]);
//statement here,line 112

// % Lines 113--113:
//            end

goto label_31; //branch to end IF
label_32: ; //end IF clause
label_31: ; //end IF
//statement here,line 113

// % Lines 114--115:
//        else

//            Ph1 = -100;

goto label_29; //branch to end IF
label_30: ; //end IF clause
tmcScalar(reg[383],1.000000000000000e+002);
tmcNeg(reg[384],reg[383]);

tmcAssign(Ph1,reg[384]);
//statement here,line 115

// % Lines 116--116:
//        end

label_33: ; //end IF clause
label_29: ; //end IF
//statement here,line 116

// % Lines 117--118:
//        

//        CL = abs(Lopen./(1+Lopen));


tmcScalar(reg[387],1.000000000000000e+000);

tmcAdd(reg[389],reg[387],Lopen);
tmcDivScalar(reg[390],Lopen,reg[389]);
//CALL function
tmcReallocRegister(reg[391]);
tmcabs(1,1, reg[391], reg[390]);

tmcAssign(CL,reg[391]);
//statement here,line 118

// % Lines 119--124:
//        % Ph1=1000;

//        if ~isempty(II1) && Ph1 >= Ph2 && max(abs(CL)) < NomC && max(abs(CL)) > 1.05 

//            %             plot(unwrap(angle(Lopen))/pi*180,20*log10(abs(Lopen)),'b',...

//            %                 angle(L1)/pi*180-360,20*log10(abs(L1)),'go',...

//            %                 angle(L2)/pi*180 ,20*log10(abs(L2)),'ro');grid on;hold on;

//            Sol=[ Sol ; Kp(kk),Ki(kk),w(II1)/2/pi];


//CALL function
tmcReallocRegister(reg[397]);
tmcisempty(1,1, reg[397], II1);
tmcNot(reg[398],reg[397]);
if(tmcIsFalse(reg[398])) {
	tmcAssignFalse(reg[395]); goto label_38; } // return(false) boolean_and expr


tmcGe(reg[401],Ph1,Ph2);
tmcAssignBool(reg[395],reg[401]);
label_38: ; //end boolean expr
if(tmcIsFalse(reg[395])) {
	tmcAssignFalse(reg[394]); goto label_37; } // return(false) boolean_and expr

//CALL function
tmcReallocRegister(reg[403]);
tmcabs(1,1, reg[403], CL);
//CALL function
tmcReallocRegister(reg[404]);
tmcReallocRegister(reg[405]);
tmcmax(1,1, reg[404], reg[405], reg[403],NULL,NULL);

tmcLt(reg[407],reg[404],NomC);
tmcAssignBool(reg[394],reg[407]);
label_37: ; //end boolean expr
if(tmcIsFalse(reg[394])) {
	tmcAssignFalse(reg[393]); goto label_36; } // return(false) boolean_and expr

//CALL function
tmcReallocRegister(reg[409]);
tmcabs(1,1, reg[409], CL);
//CALL function
tmcReallocRegister(reg[410]);
tmcReallocRegister(reg[411]);
tmcmax(1,1, reg[410], reg[411], reg[409],NULL,NULL);
tmcScalar(reg[412],1.050000000000000e+000);
tmcGt(reg[413],reg[410],reg[412]);
tmcAssignBool(reg[393],reg[413]);
label_36: ; //end boolean expr
if(tmcIsFalse(reg[393])) goto label_35; // goto to the end of the clause if the expression is false

tmcCollectColumns(reg[415],1,Sol);


tmcGetByIndex(reg[418],Kp,1,kk);


tmcGetByIndex(reg[421],Ki,1,kk);


tmcGetByIndex(reg[424],w,1,II1);
tmcScalar(reg[425],2.000000000000000e+000);
tmcDiv(reg[426],reg[424],reg[425]);
//CALL function
tmcReallocRegister(reg[427]);
tmcpi(1,0, reg[427]);
tmcDiv(reg[428],reg[426],reg[427]);
tmcCollectColumns(reg[429],3,reg[418],reg[421],reg[428]);
tmcCollectRows(reg[430],2,reg[415],reg[429]);

tmcAssign(Sol,reg[430]);
//statement here,line 124

// % Lines 125--125:
//        end

goto label_34; //branch to end IF
label_35: ; //end IF clause
label_34: ; //end IF
//statement here,line 125

// % Lines 126--126:
//    end

label_26: ; //FOR end
goto label_28; //branch to FOR begin
label_27: ; //FOR exit
//statement here,line 126

// % Lines 127--130:
//    %disp(Sol)

//    if  isempty(Sol)

//        % no solution found

//        disp('no solution found');


//CALL function
tmcReallocRegister(reg[433]);
tmcisempty(1,1, reg[433], Sol);
if(tmcIsFalse(reg[433])) goto label_40; // goto to the end of the clause if the expression is false
tmcCreateString(reg[435],"no solution found");
//CALL function
tmcReallocRegister(reg[436]);
tmcdisp(0,1, reg[436], reg[435]);
//statement here,line 130

// % Lines 131--131:
//        continue;

goto label_23; //continue to WHILE end
//statement here,line 131

// % Lines 132--132:
//    end

goto label_39; //branch to end IF
label_40: ; //end IF clause
label_39: ; //end IF
//statement here,line 132

// % Lines 133--133:
//    [YY,n]=max(Sol(:,2));


tmcCreateMagicColon(reg[438]);
tmcScalar(reg[439],2.000000000000000e+000);
tmcGetByIndex(reg[440],Sol,2,reg[438],reg[439]);
//CALL function
tmcReallocRegister(reg[441]);
tmcReallocRegister(reg[442]);
tmcmax(2,1, reg[441], reg[442], reg[440],NULL,NULL);

tmcAssign(YY,reg[441]);

tmcAssign(n,reg[442]);
//statement here,line 133

// % Lines 134--134:
//    kp0=Sol(n,1);ki0=Sol(n,2);



tmcScalar(reg[447],1.000000000000000e+000);
tmcGetByIndex(reg[448],Sol,2,n,reg[447]);

tmcAssign(kp0,reg[448]);
//statement here,line 134



tmcScalar(reg[452],2.000000000000000e+000);
tmcGetByIndex(reg[453],Sol,2,n,reg[452]);

tmcAssign(ki0,reg[453]);
//statement here,line 134

// % Lines 135--135:
//    Lopen0 = (kp0+ki0./s)./(R+s*L) .* exp(-(D+Ts).*s);




tmcDivScalar(reg[458],ki0,s);
tmcAdd(reg[459],kp0,reg[458]);



tmcMul(reg[463],s,L);
tmcAdd(reg[464],R,reg[463]);
tmcDivScalar(reg[465],reg[459],reg[464]);


tmcAdd(reg[468],D,Ts);
tmcNeg(reg[469],reg[468]);

tmcMulScalar(reg[471],reg[469],s);
//CALL function
tmcReallocRegister(reg[472]);
tmcexp(1,1, reg[472], reg[471]);
tmcMulScalar(reg[473],reg[465],reg[472]);

tmcAssign(Lopen0,reg[473]);
//statement here,line 135

// % Lines 136--149:
//    %  Lopen0 = (kp0+Ts*ki0./(z-1))./(R+s*L) .* exp(-(D+Ts).*s);

//    

//    %%// plot(unwrap(angle(Lopen0))/pi*180,20*log10(abs(Lopen0)),'m.-',...

//    %%//     angle(L1)/pi*180-360,20*log10(abs(L1)),'go',...

//    %%//     angle(L2)/pi*180 ,20*log10(abs(L2)),'ro');grid on;hold on;

//    

//    %     sysP = tf(1,[L,R]) * tf([kp0,ki0],[1,0] );

//    %     sysCL = sysP/(1+sysP);

//    % figure(999);

//    % step(sysCL,3e-3);

//    

//    %%    figure(1000);

//    

//    rden= -R/L;


tmcNeg(reg[476],R);

tmcDiv(reg[478],reg[476],L);

tmcAssign(rden,reg[478]);
//statement here,line 149

// % Lines 150--150:
//    rdend=exp(rden*Ts);



tmcMul(reg[482],rden,Ts);
//CALL function
tmcReallocRegister(reg[483]);
tmcexp(1,1, reg[483], reg[482]);

tmcAssign(rdend,reg[483]);
//statement here,line 150

// % Lines 151--151:
//    sysP1d=[0, 1/R*(1-rdend) ; 1,-rdend];

tmcScalar(reg[485],0.000000000000000e+000);
tmcScalar(reg[486],1.000000000000000e+000);

tmcDiv(reg[488],reg[486],R);
tmcScalar(reg[489],1.000000000000000e+000);

tmcSub(reg[491],reg[489],rdend);
tmcMul(reg[492],reg[488],reg[491]);
tmcCollectColumns(reg[493],2,reg[485],reg[492]);
tmcScalar(reg[494],1.000000000000000e+000);

tmcNeg(reg[496],rdend);
tmcCollectColumns(reg[497],2,reg[494],reg[496]);
tmcCollectRows(reg[498],2,reg[493],reg[497]);

tmcAssign(sysP1d,reg[498]);
//statement here,line 151

// % Lines 152--152:
//    sysP2d=[kp0 ,ki0*Ts-kp0 ; 1,-1];




tmcMul(reg[503],ki0,Ts);

tmcSub(reg[505],reg[503],kp0);
tmcCollectColumns(reg[506],2,kp0,reg[505]);
tmcScalar(reg[507],1.000000000000000e+000);
tmcScalar(reg[508],1.000000000000000e+000);
tmcNeg(reg[509],reg[508]);
tmcCollectColumns(reg[510],2,reg[507],reg[509]);
tmcCollectRows(reg[511],2,reg[506],reg[510]);

tmcAssign(sysP2d,reg[511]);
//statement here,line 152

// % Lines 153--154:
//    sysPd = [conv(sysP1d(1,:),sysP2d(1,:)) ; ...

//            conv(sysP1d(2,:),sysP2d(2,:))];


tmcScalar(reg[514],1.000000000000000e+000);
tmcCreateMagicColon(reg[515]);
tmcGetByIndex(reg[516],sysP1d,2,reg[514],reg[515]);

tmcScalar(reg[518],1.000000000000000e+000);
tmcCreateMagicColon(reg[519]);
tmcGetByIndex(reg[520],sysP2d,2,reg[518],reg[519]);
//CALL function
tmcReallocRegister(reg[521]);
tmcconv(1,2, reg[521], reg[516], reg[520]);
tmcCollectColumns(reg[522],1,reg[521]);

tmcScalar(reg[524],2.000000000000000e+000);
tmcCreateMagicColon(reg[525]);
tmcGetByIndex(reg[526],sysP1d,2,reg[524],reg[525]);

tmcScalar(reg[528],2.000000000000000e+000);
tmcCreateMagicColon(reg[529]);
tmcGetByIndex(reg[530],sysP2d,2,reg[528],reg[529]);
//CALL function
tmcReallocRegister(reg[531]);
tmcconv(1,2, reg[531], reg[526], reg[530]);
tmcCollectColumns(reg[532],1,reg[531]);
tmcCollectRows(reg[533],2,reg[522],reg[532]);

tmcAssign(sysPd,reg[533]);
//statement here,line 154

// % Lines 155--155:
//    sysPCLd = [ sysPd(1,:); sysPd(1,:)+sysPd(2,:) ];


tmcScalar(reg[536],1.000000000000000e+000);
tmcCreateMagicColon(reg[537]);
tmcGetByIndex(reg[538],sysPd,2,reg[536],reg[537]);
tmcCollectColumns(reg[539],1,reg[538]);

tmcScalar(reg[541],1.000000000000000e+000);
tmcCreateMagicColon(reg[542]);
tmcGetByIndex(reg[543],sysPd,2,reg[541],reg[542]);

tmcScalar(reg[545],2.000000000000000e+000);
tmcCreateMagicColon(reg[546]);
tmcGetByIndex(reg[547],sysPd,2,reg[545],reg[546]);
tmcAdd(reg[548],reg[543],reg[547]);
tmcCollectColumns(reg[549],1,reg[548]);
tmcCollectRows(reg[550],2,reg[539],reg[549]);

tmcAssign(sysPCLd,reg[550]);
//statement here,line 155

// % Lines 156--158:
//    

//    

//    num = sysPCLd(1,:);den=sysPCLd(2,:);


tmcScalar(reg[553],1.000000000000000e+000);
tmcCreateMagicColon(reg[554]);
tmcGetByIndex(reg[555],sysPCLd,2,reg[553],reg[554]);

tmcAssign(num,reg[555]);
//statement here,line 158


tmcScalar(reg[558],2.000000000000000e+000);
tmcCreateMagicColon(reg[559]);
tmcGetByIndex(reg[560],sysPCLd,2,reg[558],reg[559]);

tmcAssign(den,reg[560]);
//statement here,line 158

// % Lines 159--159:
//    yy=filter_( num,den,ones(1,floor(3e-3/Ts)));



tmcScalar(reg[564],1.000000000000000e+000);
tmcScalar(reg[565],3.000000000000000e-003);

tmcDiv(reg[567],reg[565],Ts);
//CALL function
tmcReallocRegister(reg[568]);
tmcfloor(1,1, reg[568], reg[567]);
//CALL function
tmcReallocRegister(reg[569]);
tmcones(1,2, reg[569], reg[564], reg[568]);
//CALL function
tmcReallocRegister(reg[570]);
tmcfilter_(1,3, reg[570], num, den, reg[569]);

tmcAssign(yy,reg[570]);
//statement here,line 159

// % Lines 160--161:
//    %% // plot([0:length(yy)-1]*Ts,yy,'b');grid on;hold on;

//    ActOvs = max(yy);


//CALL function
tmcReallocRegister(reg[573]);
tmcReallocRegister(reg[574]);
tmcmax(1,1, reg[573], reg[574], yy,NULL,NULL);

tmcAssign(ActOvs,reg[573]);
//statement here,line 161

// % Lines 162--164:
//    % Local optimization

//    if isempty(Ovs_Opt) || abs(ActOvs-Ovs) < abs(Ovs_Opt-Ovs)

//        Ovs_Opt=ActOvs;Lopen_opt=Lopen0;


//CALL function
tmcReallocRegister(reg[578]);
tmcisempty(1,1, reg[578], Ovs_Opt);
if(tmcIsTrue(reg[578])) {
	tmcAssignTrue(reg[576]); goto label_43;} // return(true) boolean_or expr


tmcSub(reg[581],ActOvs,Ovs);
//CALL function
tmcReallocRegister(reg[582]);
tmcabs(1,1, reg[582], reg[581]);


tmcSub(reg[585],Ovs_Opt,Ovs);
//CALL function
tmcReallocRegister(reg[586]);
tmcabs(1,1, reg[586], reg[585]);
tmcLt(reg[587],reg[582],reg[586]);
tmcAssignBool(reg[576],reg[587]);
label_43: ; //end boolean expr
if(tmcIsFalse(reg[576])) goto label_42; // goto to the end of the clause if the expression is false


tmcAssign(Ovs_Opt,ActOvs);
//statement here,line 164



tmcAssign(Lopen_opt,Lopen0);
//statement here,line 164

// % Lines 165--165:
//        CL_Opt=Lopen_opt./(1+Lopen_opt);


tmcScalar(reg[593],1.000000000000000e+000);

tmcAdd(reg[595],reg[593],Lopen_opt);
tmcDivScalar(reg[596],Lopen_opt,reg[595]);

tmcAssign(CL_Opt,reg[596]);
//statement here,line 165

// % Lines 166--166:
//        Sol_opt = [kp0,ki0];



tmcCollectColumns(reg[600],2,kp0,ki0);
tmcCollectRows(reg[601],1,reg[600]);

tmcAssign(Sol_opt,reg[601]);
//statement here,line 166

// % Lines 167--167:
//        yy_opt=yy;



tmcAssign(yy_opt,yy);
//statement here,line 167

// % Lines 168--168:
//    end

goto label_41; //branch to end IF
label_42: ; //end IF clause
label_41: ; //end IF
//statement here,line 168

// % Lines 169--170:
//    

//end

label_23: ; //FOR end
goto label_25; //branch to FOR begin
label_24: ; //FOR exit
//statement here,line 170

// % Lines 171--173:
//

//if my_rank==0 % master

//    RANKS  = [0:nActiveProc-1];


tmcScalar(reg[606],0.000000000000000e+000);
tmcEq(reg[607],my_rank,reg[606]);
if(tmcIsFalse(reg[607])) goto label_45; // goto to the end of the clause if the expression is false
tmcScalar(reg[608],0.000000000000000e+000);

tmcScalar(reg[610],1.000000000000000e+000);
tmcSub(reg[611],nActiveProc,reg[610]);
tmcCreateColonBaseLimit(reg[612],reg[608],reg[611]);
tmcCollectColumns(reg[613],1,reg[612]);
tmcCollectRows(reg[614],1,reg[613]);

tmcAssign(RANKS,reg[614]);
//statement here,line 173

// % Lines 174--175:
//    for cnt=2:nActiveProc

//        g_Sol_opt = MPI_Recv(RANKS(cnt),0,COMM);

tmcScalar(reg[616],2.000000000000000e+000);

tmcCreateColonBaseLimit(reg[618],reg[616],nActiveProc);
tmcForIterInit(reg[619],reg[618],cnt);
label_48: ; //FOR begin
if(tmcForIterNext(reg[619],reg[618])) goto label_47; // exit for


tmcGetByIndex(reg[622],RANKS,1,cnt);
tmcScalar(reg[623],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[625]);
tmcReallocRegister(reg[626]);
tmcMPI_Recv(1,3, reg[625], reg[626], reg[622], reg[623], COMM);

tmcAssign(g_Sol_opt,reg[625]);
//statement here,line 175

// % Lines 176--177:
//                 if ~isempty(g_Sol_opt)

//                     g_Ovs_Opt = MPI_Recv(RANKS(cnt),0,COMM);


//CALL function
tmcReallocRegister(reg[629]);
tmcisempty(1,1, reg[629], g_Sol_opt);
tmcNot(reg[630],reg[629]);
if(tmcIsFalse(reg[630])) goto label_50; // goto to the end of the clause if the expression is false


tmcGetByIndex(reg[633],RANKS,1,cnt);
tmcScalar(reg[634],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[636]);
tmcReallocRegister(reg[637]);
tmcMPI_Recv(1,3, reg[636], reg[637], reg[633], reg[634], COMM);

tmcAssign(g_Ovs_Opt,reg[636]);
//statement here,line 177

// % Lines 178--178:
//                     g_Lopen_opt = MPI_Recv(RANKS(cnt),0,COMM);



tmcGetByIndex(reg[641],RANKS,1,cnt);
tmcScalar(reg[642],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[644]);
tmcReallocRegister(reg[645]);
tmcMPI_Recv(1,3, reg[644], reg[645], reg[641], reg[642], COMM);

tmcAssign(g_Lopen_opt,reg[644]);
//statement here,line 178

// % Lines 179--179:
//                     g_CL_Opt = MPI_Recv(RANKS(cnt),0,COMM);



tmcGetByIndex(reg[649],RANKS,1,cnt);
tmcScalar(reg[650],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[652]);
tmcReallocRegister(reg[653]);
tmcMPI_Recv(1,3, reg[652], reg[653], reg[649], reg[650], COMM);

tmcAssign(g_CL_Opt,reg[652]);
//statement here,line 179

// % Lines 180--180:
//                     g_yy_opt = MPI_Recv(RANKS(cnt),0,COMM);



tmcGetByIndex(reg[657],RANKS,1,cnt);
tmcScalar(reg[658],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[660]);
tmcReallocRegister(reg[661]);
tmcMPI_Recv(1,3, reg[660], reg[661], reg[657], reg[658], COMM);

tmcAssign(g_yy_opt,reg[660]);
//statement here,line 180

// % Lines 181--181:
//                 end

goto label_49; //branch to end IF
label_50: ; //end IF clause
label_49: ; //end IF
//statement here,line 181

// % Lines 182--182:
//    end

label_46: ; //FOR end
goto label_48; //branch to FOR begin
label_47: ; //FOR exit
//statement here,line 182

// % Lines 183--185:
//    % Global optimization  

//        if isempty(Ovs_Opt) || abs(g_Ovs_Opt-Ovs) < abs(Ovs_Opt-Ovs)

//            Ovs_Opt=g_Ovs_Opt;


//CALL function
tmcReallocRegister(reg[665]);
tmcisempty(1,1, reg[665], Ovs_Opt);
if(tmcIsTrue(reg[665])) {
	tmcAssignTrue(reg[663]); goto label_53;} // return(true) boolean_or expr


tmcSub(reg[668],g_Ovs_Opt,Ovs);
//CALL function
tmcReallocRegister(reg[669]);
tmcabs(1,1, reg[669], reg[668]);


tmcSub(reg[672],Ovs_Opt,Ovs);
//CALL function
tmcReallocRegister(reg[673]);
tmcabs(1,1, reg[673], reg[672]);
tmcLt(reg[674],reg[669],reg[673]);
tmcAssignBool(reg[663],reg[674]);
label_53: ; //end boolean expr
if(tmcIsFalse(reg[663])) goto label_52; // goto to the end of the clause if the expression is false


tmcAssign(Ovs_Opt,g_Ovs_Opt);
//statement here,line 185

// % Lines 186--186:
//            Lopen_opt=g_Lopen_opt;



tmcAssign(Lopen_opt,g_Lopen_opt);
//statement here,line 186

// % Lines 187--187:
//            CL_Opt=g_CL_Opt;



tmcAssign(CL_Opt,g_CL_Opt);
//statement here,line 187

// % Lines 188--188:
//            Sol_opt = g_Sol_opt;



tmcAssign(Sol_opt,g_Sol_opt);
//statement here,line 188

// % Lines 189--189:
//            yy_opt=g_yy_opt;



tmcAssign(yy_opt,g_yy_opt);
//statement here,line 189

// % Lines 190--190:
//        end

goto label_51; //branch to end IF
label_52: ; //end IF clause
label_51: ; //end IF
//statement here,line 190

// % Lines 191--194:
//    

//    

//else

//    MPI_Send(Sol_opt,0,0,COMM); 

goto label_44; //branch to end IF
label_45: ; //end IF clause

tmcScalar(reg[686],0.000000000000000e+000);
tmcScalar(reg[687],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[689]);
tmcMPI_Send(0,4, reg[689], Sol_opt, reg[686], reg[687], COMM);
//statement here,line 194

// % Lines 195--196:
//        if ~isempty( Sol_opt)

//         MPI_Send([Ovs_Opt],0,0,COMM);   


//CALL function
tmcReallocRegister(reg[691]);
tmcisempty(1,1, reg[691], Sol_opt);
tmcNot(reg[692],reg[691]);
if(tmcIsFalse(reg[692])) goto label_56; // goto to the end of the clause if the expression is false

tmcCollectColumns(reg[694],1,Ovs_Opt);
tmcCollectRows(reg[695],1,reg[694]);
tmcScalar(reg[696],0.000000000000000e+000);
tmcScalar(reg[697],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[699]);
tmcMPI_Send(0,4, reg[699], reg[695], reg[696], reg[697], COMM);
//statement here,line 196

// % Lines 197--197:
//         MPI_Send([Lopen_opt],0,0,COMM);


tmcCollectColumns(reg[701],1,Lopen_opt);
tmcCollectRows(reg[702],1,reg[701]);
tmcScalar(reg[703],0.000000000000000e+000);
tmcScalar(reg[704],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[706]);
tmcMPI_Send(0,4, reg[706], reg[702], reg[703], reg[704], COMM);
//statement here,line 197

// % Lines 198--198:
//         MPI_Send([CL_Opt],0,0,COMM);


tmcCollectColumns(reg[708],1,CL_Opt);
tmcCollectRows(reg[709],1,reg[708]);
tmcScalar(reg[710],0.000000000000000e+000);
tmcScalar(reg[711],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[713]);
tmcMPI_Send(0,4, reg[713], reg[709], reg[710], reg[711], COMM);
//statement here,line 198

// % Lines 199--199:
//         MPI_Send([yy_opt],0,0,COMM);


tmcCollectColumns(reg[715],1,yy_opt);
tmcCollectRows(reg[716],1,reg[715]);
tmcScalar(reg[717],0.000000000000000e+000);
tmcScalar(reg[718],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[720]);
tmcMPI_Send(0,4, reg[720], reg[716], reg[717], reg[718], COMM);
//statement here,line 199

// % Lines 200--200:
//        end

goto label_55; //branch to end IF
label_56: ; //end IF clause
label_55: ; //end IF
//statement here,line 200

// % Lines 201--201:
//end

label_54: ; //end IF clause
label_44: ; //end IF
//statement here,line 201

// % Lines 202--204:
//%% // plot([0:length(yy)-1]*Ts,yy_opt,'r-');grid on;hold on;

//if ~isempty(Sol_opt)

//    PropGain=Sol_opt(1);


//CALL function
tmcReallocRegister(reg[722]);
tmcisempty(1,1, reg[722], Sol_opt);
tmcNot(reg[723],reg[722]);
if(tmcIsFalse(reg[723])) goto label_58; // goto to the end of the clause if the expression is false

tmcScalar(reg[725],1.000000000000000e+000);
tmcGetByIndex(reg[726],Sol_opt,1,reg[725]);

tmcAssign(PropGain,reg[726]);
//statement here,line 204

// % Lines 205--205:
//    IntGain=Sol_opt(2);


tmcScalar(reg[729],2.000000000000000e+000);
tmcGetByIndex(reg[730],Sol_opt,1,reg[729]);

tmcAssign(IntGain,reg[730]);
//statement here,line 205

// % Lines 206--206:
//    FreqHz = w/2/pi;


tmcScalar(reg[733],2.000000000000000e+000);
tmcDiv(reg[734],w,reg[733]);
//CALL function
tmcReallocRegister(reg[735]);
tmcpi(1,0, reg[735]);
tmcDiv(reg[736],reg[734],reg[735]);

tmcAssign(FreqHz,reg[736]);
//statement here,line 206

// % Lines 207--207:
//    FreqLen=length(FreqHz);


//CALL function
tmcReallocRegister(reg[739]);
tmclength(1,1, reg[739], FreqHz);

tmcAssign(FreqLen,reg[739]);
//statement here,line 207

// % Lines 208--208:
//    CL_Opt=Lopen_opt./(1+Lopen_opt);


tmcScalar(reg[742],1.000000000000000e+000);

tmcAdd(reg[744],reg[742],Lopen_opt);
tmcDivScalar(reg[745],Lopen_opt,reg[744]);

tmcAssign(CL_Opt,reg[745]);
//statement here,line 208

// % Lines 209--209:
//    OL_Mag = 20*log10(abs(Lopen_opt));

tmcScalar(reg[747],2.000000000000000e+001);

//CALL function
tmcReallocRegister(reg[749]);
tmcabs(1,1, reg[749], Lopen_opt);
//CALL function
tmcReallocRegister(reg[750]);
tmclog10(1,1, reg[750], reg[749]);
tmcMul(reg[751],reg[747],reg[750]);

tmcAssign(OL_Mag,reg[751]);
//statement here,line 209

// % Lines 210--210:
//    OL_Ph = unwrap(angle(Lopen_opt))/pi*180;


//CALL function
tmcReallocRegister(reg[754]);
tmcangle(1,1, reg[754], Lopen_opt);
//CALL function
tmcReallocRegister(reg[755]);
tmcunwrap(1,1, reg[755], reg[754],NULL);
//CALL function
tmcReallocRegister(reg[756]);
tmcpi(1,0, reg[756]);
tmcDiv(reg[757],reg[755],reg[756]);
tmcScalar(reg[758],1.800000000000000e+002);
tmcMul(reg[759],reg[757],reg[758]);

tmcAssign(OL_Ph,reg[759]);
//statement here,line 210

// % Lines 211--211:
//    CL_Mag = 20*log10(abs(CL_Opt));

tmcScalar(reg[761],2.000000000000000e+001);

//CALL function
tmcReallocRegister(reg[763]);
tmcabs(1,1, reg[763], CL_Opt);
//CALL function
tmcReallocRegister(reg[764]);
tmclog10(1,1, reg[764], reg[763]);
tmcMul(reg[765],reg[761],reg[764]);

tmcAssign(CL_Mag,reg[765]);
//statement here,line 211

// % Lines 212--212:
//    CL_Ph = unwrap(angle(CL_Opt))/pi*180;


//CALL function
tmcReallocRegister(reg[768]);
tmcangle(1,1, reg[768], CL_Opt);
//CALL function
tmcReallocRegister(reg[769]);
tmcunwrap(1,1, reg[769], reg[768],NULL);
//CALL function
tmcReallocRegister(reg[770]);
tmcpi(1,0, reg[770]);
tmcDiv(reg[771],reg[769],reg[770]);
tmcScalar(reg[772],1.800000000000000e+002);
tmcMul(reg[773],reg[771],reg[772]);

tmcAssign(CL_Ph,reg[773]);
//statement here,line 212

// % Lines 213--213:
//    RespTime = [0:length(yy_opt)-1]*Ts;

tmcScalar(reg[775],0.000000000000000e+000);

//CALL function
tmcReallocRegister(reg[777]);
tmclength(1,1, reg[777], yy_opt);
tmcScalar(reg[778],1.000000000000000e+000);
tmcSub(reg[779],reg[777],reg[778]);
tmcCreateColonBaseLimit(reg[780],reg[775],reg[779]);
tmcCollectColumns(reg[781],1,reg[780]);
tmcCollectRows(reg[782],1,reg[781]);

tmcMul(reg[784],reg[782],Ts);

tmcAssign(RespTime,reg[784]);
//statement here,line 213

// % Lines 214--214:
//    Resp=yy_opt;



tmcAssign(Resp,yy_opt);
//statement here,line 214

// % Lines 215--215:
//    RespLen=length(RespTime);


//CALL function
tmcReallocRegister(reg[789]);
tmclength(1,1, reg[789], RespTime);

tmcAssign(RespLen,reg[789]);
//statement here,line 215

// % Lines 216--221:
//    % figure(3000);

//    % subplot(2,1,1);

//    % semilogx(FreqHz,CL_Mag,'b');ylabel('db');grid on;

//    % subplot(2,1,2);

//    % semilogx(FreqHz,CL_Ph,'b');ylabel('Deg');grid on;xlabel('Hz');

//    save('result.mat','PropGain','IntGain','OL_Mag','OL_Ph','CL_Mag','CL_Ph','RespTime','Resp','R','L','Ts','Ovs');

tmcCreateString(reg[791],"result.mat");
//CALL function save
tmcsave(0,13, reg[791], PropGain, "PropGain", IntGain, "IntGain", OL_Mag, "OL_Mag", OL_Ph, "OL_Ph", CL_Mag, "CL_Mag", CL_Ph, "CL_Ph", RespTime, "RespTime", Resp, "Resp",
 R, "R", L, "L", Ts, "Ts", Ovs, "Ovs");
//statement here,line 221

// % Lines 222--226:
//    % 

//    % figure(2000);

//    % subplot(2,1,1);

//    %bode(sysCL);

//end

goto label_57; //branch to end IF
label_58: ; //end IF clause
label_57: ; //end IF
//statement here,line 226

// % Lines 227--235:
//

//

//

//

//

//

//

//

label_1: ; //end Function
FINALLY
tmcFreeLocalVar(g_yy_opt);
tmcFreeLocalVar(g_CL_Opt);
tmcFreeLocalVar(g_Lopen_opt);
tmcFreeLocalVar(g_Ovs_Opt);
tmcFreeLocalVar(g_Sol_opt);
tmcFreeLocalVar(CL_Opt);
tmcFreeLocalVar(ActOvs);
tmcFreeLocalVar(yy);
tmcFreeLocalVar(den);
tmcFreeLocalVar(num);
tmcFreeLocalVar(sysPCLd);
tmcFreeLocalVar(sysPd);
tmcFreeLocalVar(sysP2d);
tmcFreeLocalVar(sysP1d);
tmcFreeLocalVar(rdend);
tmcFreeLocalVar(rden);
tmcFreeLocalVar(Lopen0);
tmcFreeLocalVar(ki0);
tmcFreeLocalVar(kp0);
tmcFreeLocalVar(n);
tmcFreeLocalVar(YY);
tmcFreeLocalVar(CL);
tmcFreeLocalVar(Ph1);
tmcFreeLocalVar(II1);
tmcFreeLocalVar(Lopen);
tmcFreeLocalVar(Sol);
tmcFreeLocalVar(NomC);
tmcFreeLocalVar(yy_opt);
tmcFreeLocalVar(MyTask);
tmcFreeLocalVar(INFO);
tmcFreeLocalVar(cnt);
tmcFreeLocalVar(nActiveProc);
tmcFreeLocalVar(RANKS);
tmcFreeLocalVar(kk);
tmcFreeLocalVar(PortionPerProcess);
tmcFreeLocalVar(Tasks);
tmcFreeLocalVar(LL);
tmcFreeLocalVar(Ovs_array_len);
tmcFreeLocalVar(Ovs_array);
tmcFreeLocalVar(Lopen_opt);
tmcFreeLocalVar(Ovs_Opt);
tmcFreeLocalVar(Sol_opt);
tmcFreeLocalVar(Ph2);
tmcFreeLocalVar(z);
tmcFreeLocalVar(s);
tmcFreeLocalVar(w);
tmcFreeLocalVar(II);
tmcFreeLocalVar(Kp);
tmcFreeLocalVar(Ki);
tmcFreeLocalVar(LL1);
tmcFreeLocalVar(B1);
tmcFreeLocalVar(s1);
tmcFreeLocalVar(w1);
tmcFreeLocalVar(L2);
tmcFreeLocalVar(L1);
tmcFreeLocalVar(MaxW);
tmcFreeLocalVar(GainM);
tmcFreeLocalVar(PhaseM);
tmcFreeLocalVar(D);
tmcFreeLocalVar(str);
tmcFreeLocalVar(my_rank);
tmcFreeLocalVar(numproc);
tmcFreeLocalVar(COMM);
tmcFreeLocalVar(Ovs);
tmcFreeLocalVar(Ts);
tmcFreeLocalVar(L);
tmcFreeLocalVar(R);
tmcFreeRegFrame(reg);

TMC_DBG_POP_STACK_VAR(82);

ENDFINALLY
}

//FUNCTION DEFINITION ENDED
//statement here,line 235

// % Lines 236--236:
