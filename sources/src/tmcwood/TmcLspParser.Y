// Parser for tmclsp-files generated by free m2tmclsp utility
%{
//! Gramma for lsp-file parser
/******************************************************************************
 * Copyright (c) 2009-2015 by Shmuel Safonov.
 * All rights are reserved.
 * The TMC software is covered under GPL license. Other usage possibilities
 * are also available under commercial license terms. 
  *****************************************************************************/

#include <stdio.h>
#ifndef LINUX_GPL
#include <io.h>
#endif
#include <string.h>
#include <stdlib.h>

#include <string>
#include <list>


#include "tmcpar_tree.h"
#include "tmcpar_utils.h"

%}

%name-prefix="tmclsp_"

// Types of lexems (union type for tmclsp_lval var)
%union
{
	char   *str;
	double num;
	LSP_IDENT   ident;
	struct tree_const_val *lsp_const_val;

// expressions
	class T_ident *lsp_ident_val;
	class T_const   *lsp_constant_val;
	class T_expr_bin *lsp_binary_expression_val;
	class T_expr_bool *lsp_boolean_expression_val;
	class T_expr_unar *lsp_unary_expression_val;
	class T_expr_gen *lsp_expression_val;
	class T_expr_col *lsp_colon_expression_val;
	class L_args *lsp_argument_list_val;
	class tree_matrix *lsp_list_of_argument_list_val;
	class tree_matrix   *lsp_cell_val;
	class T_expr_index	*lsp_index_expression_val;
	class T_expr_assign_one *lsp_simple_assignment_val;
	class T_expr_assign_many *lsp_multi_assignment_val;
	class T_expr_func *lsp_fcn_handle_val;
// statements
	class T_stmnt_gen *lsp_statement_val;
//	class generic_tree *lsp_t_generic_val;
	class T_cmd_gen *lsp_command_val;
// commands
	class T_cmd_ctrl_return*	lsp_return_command_val;
	class T_cmd_decl_gen*	lsp_T_cmd_decl_gen_val;
	class T_cmd_ctrl_label*	lsp_T_cmd_ctrl_label_val;
	class T_ctrl_cmd_if*		lsp_T_ctrl_cmd_if_val;
	class T_ctrl_cmd_while*	lsp_T_ctrl_cmd_while_val;
	class T_ctrl_cmd_continue* lsp_T_ctrl_cmd_continue_val;
	class T_ctrl_cmd_break*	lsp_T_ctrl_cmd_break_val;
	class T_ctrl_cmd_switch*	lsp_T_ctrl_cmd_switch_val;
	class T_ctrl_cmd_try_catch*		lsp_tree_try_command_val;
	class T_ctrl_cmd_for*		lsp_T_ctrl_cmd_for_val;
	class T_func_hdr*    lsp_T_func_hdr_val;
	
// used in declarations	
	class L_vardecl*  lsp_L_vardecl_val;	
// used in if command
	class T_if_block*		lsp_T_if_block_val;
	class LT_if_blocks* lsp_LT_if_blocks_val; // list of clauses
// used in if,while,switch and for
	class L_stmnt_gen* lsp_L_stmnt_gen_val;
// used in switch
	class LT_sw_cases* lsp_LT_sw_cases_val;
	class T_sw_case*		 lsp_T_sw_case_val;
// used in function def
	class T_func_block*    lsp_T_func_block_val;
	
}
// terminal symbos (lexems) definitions with their types
%token	<ident> IDENT
%token  <num>   NUMBER
%token  <str>   STRING
%token  NIL
%token  LPAREN
%token  RPAREN
%token  EQ
%token  TCONST COL LINE TYPE  STATEMENT FUNC USR_FUNC FNC_DEF PARAMS TREE STATEMENTS TIDENT RESULTS NAME STMNT VAL
%token  LIST PAR
%token  END_OF_INPUT
%token  NO_OP_CMD CMD DECL_CMD DECL DECLARS
%token  OP S_ASSIGN LHS RHS COLON_EXPR BASE LIM INC MULTI_ASSIGN
%token  OPERAND UN_EXPR
%token  INDX_EXPR FN_EXPR ARGS INDEXED_EXPR ARGUMENT FIELD BIN_EXPR BOOL_EXPR
%token  RETURN BREAK CONTINUE 
%token  IF IF_EXP IF_CLAUSE IF_CMDS 
%token  WHILE W_EXP
%token  SW_EXP SWITCH SW_CASES SW_CASE CASE_LABEL
%token  CELL MATRIX ROWS ARGUMENT_LIST ARGUMENTS
%token  LMODIFY_EXP REVAL_EXP FOR PFOR
%token FUNC_HANDLE
%token TRY TRYCODE CATCHCODE
%token UNTIL U_EXP
%token MAGIC_COL

// non-terminal symbols with their types
%type <lsp_ident_val> ident
%type <lsp_constant_val> const
%type <lsp_const_val> variant_val
%type <lsp_expression_val> expression case_label
%type <lsp_binary_expression_val> bin_expr
%type <lsp_boolean_expression_val> bool_expr
%type <lsp_unary_expression_val> un_expr
%type <lsp_colon_expression_val> colon_expr
%type <lsp_argument_list_val> list_argument t_list_argument argument_list // list of expressions
%type <lsp_list_of_argument_list_val> list_of_argument_list t_list_of_argument_list matrix
%type <lsp_cell_val> cell
%type <lsp_index_expression_val> indx_expr by_index by_field
%type <lsp_simple_assignment_val> s_assign
%type <lsp_multi_assignment_val> multi_assign
%type <lsp_fcn_handle_val> fcn_handle

%type <lsp_statement_val> statement
//%type <lsp_t_generic_val> t_generic
%type <lsp_command_val> command

%type <lsp_return_command_val> return
%type <lsp_T_cmd_decl_gen_val> decl_cmd
%type <lsp_T_cmd_ctrl_label_val> no_op_cmd
%type <lsp_T_ctrl_cmd_if_val> if
%type <lsp_T_ctrl_cmd_while_val> while
%type <lsp_T_ctrl_cmd_continue_val> continue
%type <lsp_T_ctrl_cmd_break_val> break
%type <lsp_T_ctrl_cmd_switch_val> switch
%type <lsp_tree_try_command_val> try
%type <lsp_T_ctrl_cmd_for_val> for

%type <lsp_L_vardecl_val> t_list_decl list_par t_list_par list_ident 
%type <lsp_T_if_block_val> if_clause
%type <lsp_LT_if_blocks_val> t_if_clause list_if_clause
%type <lsp_L_stmnt_gen_val> t_list_statement list_statement module list_function

%type <lsp_T_sw_case_val> switch_case
%type <lsp_LT_sw_cases_val> t_switch_case list_switch_case

%type <lsp_T_func_hdr_val> func_def_statement fnc_def  
%type <lsp_T_func_block_val>  T_func_block


%start module

%%

module	: list_function	END_OF_INPUT
		{
			$$=$1;
			tmcpar_parsing_module = $$;
			YYACCEPT;
		}
		;

list_function
		:	func_def_statement
		{
            $$ = create_module($1);
        }
		|   list_function func_def_statement
		{
            $$ = append_to_module($1,$2);
        }		
		;


//module : func_def_statement END_OF_INPUT
//		{
//		//printf("Module finished\n");
//		tmclsp_parsing_module = $1;
//		$$ = $1;
//		YYACCEPT;
//		}
//		;

// Special type of statement: function definition. Only single function for a file module is permitted.
func_def_statement : LPAREN TREE EQ STATEMENT LINE EQ NUMBER COL EQ NUMBER STMNT EQ fnc_def RPAREN
		{
			$$=$13;
		}
                   ;

fnc_def            : LPAREN TREE EQ FNC_DEF LINE EQ NUMBER COL EQ NUMBER NAME EQ IDENT FUNC EQ T_func_block RPAREN
					{
							$$ = create_func_def_statement($16,(int)$7,(int)$10);
					}
                   ;

T_func_block           : LPAREN TREE EQ USR_FUNC LINE EQ NUMBER COL EQ NUMBER NAME EQ IDENT PARAMS EQ  t_list_par  RESULTS EQ  t_list_par  STATEMENTS EQ t_list_statement  RPAREN
					{
						$$ = create_func_body($13,$16,$19,$22,(int)$7,(int)$10);
					}
                   ;
                   
statement          : LPAREN TREE EQ STATEMENT LINE EQ NUMBER COL EQ NUMBER STMNT EQ expression RPAREN
                   {
                    $$ = create_expression($13,(int)$7,(int)$10);
                   }
				   | LPAREN TREE EQ STATEMENT LINE EQ NUMBER COL EQ NUMBER STMNT EQ command RPAREN
                   {
                    $$ = create_command($13,(int)$7,(int)$10);
                   }                   
                   ;

expression		:  ident
					{
					$$=(T_expr_gen*)$1;
					}
                | nil
					{
					$$=(T_expr_gen*)0;
					}
				|  const
					{
					$$=(T_expr_gen*)$1;
					}
				|  colon_expr
				{
					$$=(T_expr_gen*)$1;
				}
                |  s_assign
				{
					$$=(T_expr_gen*)$1;
				}
				|  indx_expr
					{
					$$=(T_expr_gen*)$1;
					}
                | bin_expr
					{
					$$=(T_expr_gen*)$1;
					}
                | bool_expr
					{
					$$=(T_expr_gen*)$1;
					}
                 | un_expr
 					{
					$$=(T_expr_gen*)$1;
					}
               | cell
   					{
					$$=(T_expr_gen*)$1;
					}
                | matrix
   					{
					$$=(T_expr_gen*)$1;
					}
                |  fcn_handle
   					{
					$$=(T_expr_gen*)$1;
					}
                |  multi_assign
   					{
					$$=(T_expr_gen*)$1;
					}
				; 
nil : 			LPAREN NIL RPAREN


	
command		       : return
   					{
					$$=(T_cmd_gen*)$1;
					}
                   | decl_cmd
   					{
					$$=(T_cmd_gen*)$1;
					}
                   | no_op_cmd
   					{
					$$=(T_cmd_gen*)$1;
					}
                   | if
   					{
					$$=(T_cmd_gen*)$1;
					}
                   | while
    					{
					$$=(T_cmd_gen*)$1;
					}
                  | continue
    					{
					$$=(T_cmd_gen*)$1;
					}
                  | break
   					{
					$$=(T_cmd_gen*)$1;
					}
                   | switch
   					{
					$$=(T_cmd_gen*)$1;
					}
                   | for
   					{
					$$=(T_cmd_gen*)$1;
					}
//                   | xfor
//   					{
//					$$=(T_cmd_gen*)$1;
//					}
                  | try
   					{
					$$=(T_cmd_gen*)$1;
					}
//                  | until
//  					{
//  					YYABORT;
//					//$$=(T_cmd_gen*)$1;
//					}
				   ;
					
//t_generic        : expression
//   					{
//					$$=(generic_tree*)$1;
//					}
//                  | command
//  					{
//					$$=(generic_tree*)$1;
//					}
//				   ;
                   

t_list_par		   : LPAREN LIST EQ PAR list_par RPAREN
					{
					$$=$5;
					}
					| nil
					{
					$$=0;
					}
					;
					
list_par           : ident
					{
					$$ = create_list_ident($1);
					}
                   | list_par ident
					{
                   	$$ = append_to_list_ident($1,$2);
					}
					| NIL
					{
                   	$$ = create_list_ident_empty();
					}
                   ;
t_list_statement :   LPAREN LIST EQ STATEMENT list_statement RPAREN
				     {
					 $$ = $5;
					 }
					| LPAREN LIST EQ STATEMENT  RPAREN /* hazard : no statements */
					{
					$$ = create_statement_list_empty();
					}
					;                 
list_statement     : statement
                   {
                   $$ = create_statement_list($1);
                   }
                   | list_statement statement
                   {
                   $$ = append_to_statement_list($1,$2);
                   }
                   | NIL
                   {
                   $$ = create_statement_list_empty();
                   }
                   ;
ident              : LPAREN TREE EQ  TIDENT LINE EQ NUMBER COL EQ NUMBER NAME EQ IDENT    RPAREN
					{
					 $$ = create_identifier($13,(int)$7,(int)$10);
					 }
                   ;
const              : LPAREN TREE EQ  TCONST LINE EQ NUMBER COL EQ NUMBER  TYPE EQ IDENT  VAL EQ variant_val RPAREN
					{
					 $$ = create_constant((enum CONST_VAL_TYPES)0,$16,(int)$7,(int)$10);
					}
					
                   ;
variant_val        : NUMBER
					{
					 $$ = make_number($1,0,const_val_real);
					}
                   | LPAREN NUMBER NUMBER RPAREN
                   {
                     $$ = make_number($2,$3,const_val_complex);
                   }
                   | STRING
                   {
					 $$ = make_string($1);
                   }
                   | nil
                   {
                     $$ =  make_empty_matrix();
                   }
                   ;
                   | LPAREN MAGIC_COL RPAREN
                   {
                     $$ =  make_magic_col();
                   }
                   ;
t_list_decl : LPAREN LIST EQ DECL list_ident RPAREN
		{
				$$ = $5;
		}
		;
			
list_ident : list_par
		{
			$$=$1;
		}
		;
		
s_assign : LPAREN TREE EQ  S_ASSIGN LINE EQ NUMBER COL EQ NUMBER  TYPE EQ NUMBER  OP EQ IDENT LHS EQ expression  RHS EQ expression RPAREN
	{
	 $$ = create_s_assignment_expression((int)$13,$16,$19,$22,(int)$7,(int)$10);
	}
	;
multi_assign : LPAREN TREE EQ  MULTI_ASSIGN LINE EQ NUMBER COL EQ NUMBER  TYPE EQ NUMBER  OP EQ IDENT LHS EQ argument_list  RHS EQ expression RPAREN
	{
	 $$ = create_m_assignment_expression((int)$13,$16,$19,$22,(int)$7,(int)$10);
	}

colon_expr : LPAREN TREE EQ  COLON_EXPR LINE EQ NUMBER COL EQ NUMBER  BASE EQ expression  LIM EQ  expression INC EQ  expression RPAREN
	{
	 $$ = create_colon_expression($13,$16,$19,(int)$7,(int)$10);
	}
	;

indx_expr : by_index
	 {
	  $$ =$1;
	 }
	 | by_field
	 {
	  $$ = $1;
	 }
	  ;
by_index : 	LPAREN TREE EQ  INDX_EXPR LINE EQ NUMBER COL EQ NUMBER  TYPE EQ IDENT   ARGS EQ t_list_argument INDEXED_EXPR EQ expression RPAREN	  
		{
			$$ = create_ref_index($13,$16,$19,(int)$7,(int)$10);
		}
		;
t_list_argument :  LPAREN LIST EQ ARGUMENT list_argument RPAREN
			{
				$$ = $5;
			}

list_argument : expression
			{
				$$=create_argument_list($1);
			}
			| list_argument expression
			{
				$$=append_to_argument_list($1,$2);
			}
			;
by_field : 	LPAREN TREE EQ  FN_EXPR LINE EQ NUMBER COL EQ NUMBER  TYPE EQ IDENT   FIELD EQ IDENT INDEXED_EXPR EQ expression RPAREN
		{
			$$ = create_ref_field($13,$16,$19,(int)$7,(int)$10);
		}
		;
		  
bin_expr : 	LPAREN TREE EQ  BIN_EXPR LINE EQ NUMBER COL EQ NUMBER  TYPE EQ NUMBER OP EQ IDENT LHS EQ expression RHS EQ expression  RPAREN	  
		{
			$$ = create_binary_expression($16,$19,$22,(int)$7,(int)$10);
		}
		;
		
bool_expr : LPAREN TREE EQ  BOOL_EXPR LINE EQ NUMBER COL EQ NUMBER  TYPE EQ NUMBER OP EQ IDENT LHS EQ expression RHS EQ expression  RPAREN	  
		{
			$$ = create_boolean_expression($16,$19,$22,(int)$7,(int)$10);
		}
		;

un_expr : 	LPAREN TREE EQ  UN_EXPR LINE EQ NUMBER COL EQ NUMBER  TYPE EQ NUMBER OP EQ IDENT OPERAND EQ expression  RPAREN	  
		{
			$$ = create_unary_expression($16,$19,(int)$7,(int)$10);
		}
		;
cell   : LPAREN TREE EQ CELL  LINE EQ NUMBER COL EQ NUMBER ROWS EQ t_list_of_argument_list RPAREN 
		{
			$$ = create_cell_array($13); // convert matrix to cell array
		}
		;
matrix : LPAREN TREE EQ MATRIX LINE EQ NUMBER COL EQ NUMBER ROWS EQ t_list_of_argument_list RPAREN 
		{
			$$ = $13;
		}
		;

fcn_handle : LPAREN TREE EQ FUNC_HANDLE LINE EQ NUMBER COL EQ NUMBER NAME EQ IDENT RPAREN
					{
						$$ = create_fcn_handle($13,(int)$7,(int)$10);
					}

t_list_of_argument_list : LPAREN LIST EQ ARGUMENT_LIST list_of_argument_list RPAREN
		{
			$$ = $5;
		}
		;
list_of_argument_list : argument_list
					{
						$$ = create_matrix($1);
					}
					  | list_of_argument_list argument_list
					{
						$$ = add_row_to_matrix($1,$2);
					}
					  | nil
					{
						$$ = create_empty_matrix();
					}
					  ;
argument_list : LPAREN TREE EQ ARGUMENT_LIST ARGUMENTS EQ t_list_argument RPAREN
	{
		$$ = $7;
	}

// Commands
return	:       LPAREN TREE EQ  RETURN   LINE EQ NUMBER COL EQ NUMBER RPAREN
	{
		$$=create_return((int)$7,(int)$10);
	}
	;
break	:       LPAREN TREE EQ  BREAK   LINE EQ NUMBER COL EQ NUMBER RPAREN
	{
		$$=create_break((int)$7,(int)$10);
	}
	;
continue	:   LPAREN TREE EQ  CONTINUE   LINE EQ NUMBER COL EQ NUMBER RPAREN
	{
		$$=create_continue((int)$7,(int)$10);
	}
	;
decl_cmd	:	LPAREN TREE EQ  DECL_CMD LINE EQ NUMBER COL EQ NUMBER  DECL EQ IDENT   DECLARS EQ t_list_decl RPAREN
	{
		$$=create_declaration($13,$16,(int)$7,(int)$10);
	}
	;
no_op_cmd	:   LPAREN TREE EQ  NO_OP_CMD LINE EQ NUMBER COL EQ NUMBER CMD EQ IDENT    RPAREN
	{
		$$=create_cmd_ctrl_label($13,(int)$7,(int)$10);
	}
	;
if	: LPAREN TREE EQ IF LINE EQ NUMBER COL EQ NUMBER IF_CMDS EQ t_if_clause RPAREN
	{
		$$ = create_if_statement($13,(int)$7,(int)$10);
	}
	;
t_if_clause : LPAREN LIST EQ IF_CLAUSE list_if_clause RPAREN
	{
		$$=$5;
	}
	;
	
list_if_clause	: if_clause
					{
					$$ = create_if_clause_list($1);
					}
				| list_if_clause if_clause
					{
					$$ = append_to_if_clause_list($1,$2);
					}	
				| nil
				{
					$$ = create_if_clause_list_empty();
				}
				;

if_clause : LPAREN TREE EQ IF_CLAUSE LINE EQ NUMBER COL EQ NUMBER IF_EXP EQ expression STATEMENTS EQ t_list_statement  RPAREN
				{
				$$=create_if_clause($13,$16,(int)$7,(int)$10);
				}
				;
				
while	: LPAREN TREE EQ WHILE LINE EQ NUMBER COL EQ NUMBER W_EXP EQ expression  STATEMENTS EQ t_list_statement  RPAREN
				{
				$$=create_while_command($13,$16,(int)$7,(int)$10);
				}
				;

// until   : LPAREN TREE EQ UNTIL LINE EQ NUMBER COL EQ NUMBER U_EXP EQ expression  STATEMENTS EQ t_list_statement  RPAREN

switch : LPAREN TREE EQ  SWITCH LINE EQ NUMBER COL EQ NUMBER SW_EXP EQ expression SW_CASES EQ t_switch_case RPAREN
				{
				$$=create_switch_command($13,$16,(int)$7,(int)$10);
				}
				;

t_switch_case : LPAREN LIST EQ SW_CASE list_switch_case RPAREN
				{
				$$ = $5;
				}
				;
				
list_switch_case : switch_case
					{
						$$  = create_switch_cases_list($1);
					}
				 | list_switch_case switch_case
					{
						$$  = append_to_switch_cases_list($1,$2);
					}
				 | nil
 					{
						$$  = create_switch_cases_list_empty();
					}
				 ;
switch_case : 	LPAREN TREE EQ 	SW_CASE LINE EQ NUMBER COL EQ NUMBER CASE_LABEL EQ  case_label STATEMENTS EQ t_list_statement  RPAREN
				{
				$$ = create_switch_case($13,$16,(int)$7,(int)$10);
				}
				;
case_label : expression
				{
					$$=$1;
				}
		   ;
for : LPAREN TREE EQ FOR LINE EQ NUMBER COL EQ NUMBER  LMODIFY_EXP EQ expression REVAL_EXP EQ expression 	STATEMENTS 	EQ t_list_statement  RPAREN   
				{
				$$=create_for_statement($13,$16,$19,(int)$7,(int)$10);
				}
				;

// pfor : LPAREN TREE EQ PFOR LINE EQ NUMBER COL EQ NUMBER  LMODIFY_EXP EQ expression REVAL_EXP EQ expression 	STATEMENTS 	EQ t_list_statement  RPAREN   



try : LPAREN TREE EQ  TRY LINE EQ NUMBER COL EQ NUMBER   TRYCODE EQ t_list_statement CATCHCODE EQ t_list_statement RPAREN
				{
				$$=create_try_catch_statement($13,$16,(int)$7,(int)$10);
				}
				;

%%

